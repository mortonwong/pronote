## 第 13 章　客户端检测

> **本章内容**
>
> - 使用能力检测
> - 用户代理检测的历史
> - 软件与硬件检测
> - 检测策略

虽然浏览器厂商齐心协力想要实现一致的接口，但事实上仍然是每家浏览器都有自己的长处与不足。跨平台的浏览器尽管版本相同，但总会存在不同的问题。这些差异迫使Web开发者要么面向最大公约数而设计，要么（更常见地）使用各种方法来检测客户端，以克服或避免这些缺陷。

客户端检测一直是Web开发中饱受争议的话题，这些话题普遍围绕所有浏览器应支持一系列公共特性，理想情况下是这样的。而现实当中，浏览器之间的差异和莫名其妙的行为，让客户端检测变成一种补救措施，而且也成为了开发策略的重要一环。如今，浏览器之间的差异相对IE大溃败以前已经好很多了，但浏览器间的不一致性依旧是Web开发中的常见主题。

要检测当前的浏览器有很多方法，每一种都有各自的长处和不足。问题的关键在于知道客户端检测应该是解决问题的最后一个举措。任何时候，只要有更普适的方案可选，都应该毫不犹豫地选择。首先要设计最常用的方案，然后再考虑为特定的浏览器进行补救。

## 13.1　能力检测

能力检测（又称特性检测）即在JavaScript运行时中使用一套简单的检测逻辑，测试浏览器是否支持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。能力检测的基本模式如下：

```
if (object.propertyInQuestion) {
  // 使用object.propertyInQuestion
}
```

比如，IE5之前的版本中没有`document.getElementById()`这个DOM方法，但可以通过`document.all`属性实现同样的功能。为此，可以进行如下能力检测：

```
function getElement(id) {
  if (document.getElementById) {
    return document.getElementById(id);
  } else if (document.all) {
    return document.all[id];
  } else {
    throw new Error("No way to retrieve element!");
  }
}
```

这个`getElement()`函数的目的是根据给定的ID获取元素。因为标准的方式是使用`document.getElementById()`，所以首先测试它。如果这个函数存在（不是`undefined`），那就使用这个方法；否则检测`document.all`是否存在，如果存在则使用。如果这两个能力都不存在（基本上不可能），则抛出错误说明功能无法实现。

能力检测的关键是理解两个重要概念。首先，如前所述，应该先检测最常用的方式。在前面的例子中就是先检测`document.getElementById()`再检测`document.all`。测试最常用的方案可以优化代码执行，这是因为在多数情况下都可以避免无谓检测。

其次是必须检测切实需要的特性。某个能力存在并不代表别的能力也存在。比如下面的例子：

```
function getWindowWidth() {
  if (document.all) { // 假设IE
    return document.documentElement.clientWidth; // 不正确的用法！
  } else {
    return window.innerWidth;
  }
}
```

这个例子展示了不正确的能力检测方式。`getWindowWidth()`函数首先检测`document.all`是否存在，如果存在则返回`document.documentElement.clientWidth`，理由是IE8及更低版本不支持`window.innerWidth`。这个例子的问题在于检测到`document.all`存在并不意味着浏览器是IE。事实，也可能是某个早期版本的Opera，既支持`document.all`也支持`windown.innerWidth`。

### 13.1.1　安全能力检测

能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。前一节中的例子依赖将测试对象的成员转换类型，然后再确定它是否存在。虽然这样能够确定检测的对象成员存在，但不能确定它就是你想要的。来看下面的例子，这个函数尝试检测某个对象是否可以排序：

```
// 不要这样做！错误的能力检测，只能检测到能力是否存在
function isSortable(object) {
  return !!object.sort;
}
```

这个函数尝试通过检测对象上是否有`sort()`方法来确定它是否支持排序。问题在于，即使这个对象有一个`sort`属性，这个函数也会返回`true`：

```
let result = isSortable({ sort: true });
```

简单地测试到一个属性存在并不代表这个对象就可以排序。更好的方式是检测`sort`是不是函数：

```
// 好一些，检测sort是不是函数
function isSortable(object) {
  return typeof object.sort == "function";
}
```

上面的代码中使用的`typeof`操作符可以确定`sort`是不是函数，从而确认是否可以调用它对数据进行排序。

进行能力检测时应该尽量使用`typeof`操作符，但光有它还不够。尤其是某些宿主对象并不保证对`typeof`测试返回合理的值。最有名的例子就是Internet Explorer（IE）。在多数浏览器中，下面的代码都会在`document.createElement()`存在时返回`true`：

```
// 不适用于IE8及更低版本
function hasCreateElement() {
  return typeof document.createElement == "function";
}
```

但在IE8及更低版本中，这个函数会返回`false`。这是因为`typeof document.createElement`返回`"object"`而非`"function"`。前面提到过，DOM对象是宿主对象，而宿主对象在IE8及更低版本中是通过COM而非JScript实现的。因此，`document.createElement()`函数被实现为COM对象，`typeof`返回`"object"`。IE9对DOM方法会返回`"function"`。

> **注意**　要深入了解JavaScript能力检测，推荐阅读Peter Michaux的文章“Feature Detection—State of the Art Browser Scripting”。

### 13.1.2　基于能力检测进行浏览器分析

虽然可能有人觉得能力检测类似于黑科技，但恰当地使用能力检测可以精准地分析运行代码的浏览器。使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。

1. **检测特性**

   可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么最好集中检测所有能力，而不是等到用的时候再重复检测。比如：

   ```
   // 检测浏览器是否支持Netscape式的插件
   let hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);
   
   // 检测浏览器是否具有DOM Level 1能力
   let hasDOM1 = !!(document.getElementById && document.createElement &&
            document.getElementsByTagName);
   ```

   这个例子完成了两项检测：一项是确定浏览器是否支持Netscape式的插件，另一项是检测浏览器是否具有DOM Level 1能力。保存在变量中的布尔值可以用在后面的条件语句中，这样比重复检测省事多了。
    

2. **检测浏览器**

   可以根据对浏览器特性的检测并与已知特性对比，确认用户使用的是什么浏览器。这样可以获得比用户代码嗅探（稍后讨论）更准确的结果。但未来的浏览器版本可能不适用于这套方案。

   下面来看一个例子，根据不同浏览器独有的行为推断出浏览器的身份。这里故意没有使用`navigator.userAgent`属性，后面会讨论它：

   ```
   class BrowserDetector {
     constructor() {
       // 测试条件编译
       // IE6~10支持
       this.isIE_Gte6Lte10 = /*@cc_on!@*/false;
   
       // 测试documentMode
       // IE7~11支持
       this.isIE_Gte7Lte11 = !!document.documentMode;
   
       // 测试StyleMedia构造函数
       // Edge 20及以上版本支持
       this.isEdge_Gte20 = !!window.StyleMedia;
   
       // 测试Firefox专有扩展安装API
       // 所有版本的Firefox都支持
       this.isFirefox_Gte1 = typeof InstallTrigger !== 'undefined';
   
       // 测试chrome对象及其webstore属性
       // Opera的某些版本有window.chrome，但没有window.chrome.webstore
       // 所有版本的Chrome都支持
       this.isChrome_Gte1 = !!window.chrome && !!window.chrome.webstore;
   
       // Safari早期版本会给构造函数的标签符追加"Constructor"字样，如：
       // window.Element.toString(); // [object ElementConstructor]
       // Safari 3~9.1支持
       this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element);
   
       // 推送通知API暴露在window对象上
       // 使用默认参数值以避免对undefined调用toString()
       // Safari 7.1及以上版本支持
       this.isSafari_Gte7_1 =
           (({pushNotification = {}} = {}) =>
             pushNotification.toString() == '[object SafariRemoteNotification]'
           )(window.safari);
   
       // 测试addons属性
       // Opera 20及以上版本支持
       this.isOpera_Gte20 = !!window.opr && !!window.opr.addons;
     }
   
     isIE() { return this.isIE_Gte6Lte10 || this.isIE_Gte7Lte11; }
     isEdge() { return this.isEdge_Gte20 && !this.isIE(); }
     isFirefox() { return this.isFirefox_Gte1; }
     isChrome() { return this.isChrome_Gte1; }
     isSafari() { return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1; }
     isOpera() { return this.isOpera_Gte20; }
   }
   ```

   这个类暴露的通用浏览器检测方法使用了检测浏览器范围的能力测试。随着浏览器的变迁及发展，可以不断调整底层检测逻辑，但主要的API可以保持不变。
    

3. **能力检测的局限**

   通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。以下“浏览器检测”代码（或其他类似代码）经常出现在很多网站中，但都没有正确使用能力检测：

   ```
   // 不要这样做！不够特殊
   let isFirefox = !!(navigator.vendor && navigator.vendorSub);
   
   // 不要这样做！假设太多
   let isIE = !!(document.all && document.uniqueID);
   ```

   这是错误使用能力检测的典型示例。过去，Firefox可以通过`navigator.vendor`和`navigator.vendorSub`来检测，但后来`Safari`也实现了同样的属性，于是这段代码就会产生误报。为确定IE，这段代码检测了`document.all`和`document.uniqueID`。这是假设IE将来的版本中还会继续存在这两个属性，而且其他浏览器也不会实现它们。不过这两个检测都使用双重否定操作符来产生布尔值（这样可以生成便于存储和访问的结果）。

   > **注意**　能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标志。

## 13.2　用户代理检测

用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个HTTP请求的头部，在JavaScript中可以通过`navigator.userAgent`访问。在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应操作。而在客户端，用户代理检测被认为是不可靠的，只应该在没有其他选项时再考虑。

用户代理字符串最受争议的地方就是，在很长一段时间里，浏览器都通过在用户代理字符串包含错误或误导性信息来欺骗服务器。要理解背后的原因，必须回顾一下自Web出现之后用户代理字符串的历史。

### 13.2.1　用户代理的历史

HTTP规范（1.0和1.1）要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串。RFC 2616（HTTP 1.1）是这样描述用户代理字符串的：

> 产品标记用于通过软件名称和版本来标识通信产品的身份。多数使用产品标记的字段也允许列出属于应用主要部分的子产品，以空格分隔。按照约定，产品按照标识应用重要程度的先后顺序列出。

这个规范进一步要求用户代理字符串应该是“标记/版本”形式的产品列表。但现实当中的用户代理字符串远没有那么简单。

1. **早期浏览器**

   美国国家超级计算应用中心（NCSA，National Center for Supercomputing Applications）发布于1993年的Mosaic是早期Web浏览器的代表，其用户代理字符串相当简单，类似于：

   ```
   Mosaic/0.9
   ```

   虽然在不同操作系统和平台中可能会有所不同，但基本形式都是这么简单直接。斜杠前是产品名称（有时候可能是“NCSA Mosaic”之类的），斜杠后是产品版本。

   在网景公司准备开发浏览器时，代号确定为“Mozilla”（Mosaic Killer的简写）。第一个公开发行版Netscape Navigator 2的用户代理字符串是这样的：

   ```
   Mozilla/Version [Language] (Platform; Encryption)
   ```

   网景公司遵守了将产品名称和版本作为用户代理字符串的规定，但又在后面添加了如下信息。

   - Language：语言代码，表示浏览器的目标使用语言。
   - Platform：表示浏览器所在的操作系统和/或平台。
   - Encryption：包含的安全加密类型，可能的值是U（128位加密）、I（40位加密）和N（无加密）。

   Netscape Navigator 2的典型用户代理字符串如下所示：

   ```
   Mozilla/2.02 [fr] (WinNT; I)
   ```

   这个字符串表示Netscape Navigator 2.02，在主要使用法语地区的发行，运行在Windows NT上，40位加密。总体上看，通过产品名称还是很容易知道这是什么浏览器的。
    

2. **Netscape Navigator 3和IE3**

   1996年，Netscape Navigator 3发布之后超过Mosaic成为最受欢迎的浏览器。其用户代理字符串也发生了一些小变化，删除了语言信息，并将操作系统或系统CPU信息（OS-or-CPU description）等列为可选信息。此时的格式如下：

   ```
   Mozilla/Version (Platform; Encryption [; OS-or-CPU description])
   ```

   运行在Windows系统上的Netscape Navigator 3的典型用户代理字符串如下：

   ```
   Mozilla/3.0 (Win95; U)
   ```

   这个字符串表示Netscape Navigator 3运行在Windows 95上，采用了128位加密。注意在Windows系统上，没有“OS-or-CPU”部分。

   Netscape Navigator 3发布后不久，微软也首次对外发布了IE3。这是因为当时Netscape Navigator是市场占有率最高的浏览器，很多服务器在返回网页之前都会特意检测其用户代理字符串。如果IE因此打不开网页，那么这个当时初出茅庐的浏览器就会遭受重创。为此，IE就在用户代理字符串中添加了兼容Netscape用户代理字符串的内容。结果格式为：

   ```
   Mozilla/2.0 (compatible; MSIE Version; Operating System)
   ```

   比如，Windows 95平台上的IE3.02的用户代理字符串如下：

   ```
   Mozilla/2.0 (compatible; MSIE 3.02; Windows 95)
   ```

   当时的大多数浏览器检测程序都只看用户代理字符串中的产品名称，因此IE成功地将自己伪装成了Mozilla，也就是Netscape Navigator。这个做法引发了一些争议，因为它违反了浏览器标识的初衷。另外，真正的浏览器版本也跑到了字符串中间。

   这个字符串中还有一个地方很有意思，即它将自己标识为Mozilla 2.0而不是3.0。3.0是当时市面上使用最多的版本，按理说使用这个版本更合逻辑。背后的原因至今也没有揭开，不过很可能就是当事人一时大意造成的。
    

3. **Netscape Communicator 4和IE4~8**

   1997年8月，Netscape Communicator 4发布（这次发布将Navigator改成了Communicator）。Netscape在这个版本中仍然沿用了上一个版本的格式：

   ```
   Mozilla/Version (Platform; Encryption [; OS-or-CPU description])
   ```

   比如，Windows 98上的第4版，其用户代理字符串就是这样的：

   ```
   Mozilla/4.0 (Win98; I)
   ```

   如果发布了补丁，则相应增加版本号，比如下面是4.79版的字符串：

   ```
   Mozilla/4.79 (Win98; I)
   ```

   微软在发布IE4时只更新了版本，格式不变：

   ```
   Mozilla/4.0 (compatible; MSIE Version; Operating System)
   ```

   比如，Windows 98上运行的IE4的字符串如下：

   ```
   Mozilla/4.0 (compatible; MSIE 4.0; Windows 98)
   ```

   更新版本号之后，IE的版本号跟Mozilla的就一致了，识别同为第4代的两款浏览器也方便 了。可是，这种版本同步就此打住。在IE4.5（只针对Mac）面世时，Mozilla的版本号还是4，IE的版本号却变了：

   ```
   Mozilla/4.0 (compatible; MSIE 4.5; Mac_PowerPC)
   ```

   直到IE7，Mozilla的版本号就没有变过，比如：

   ```
   Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)
   ```

   IE8在用户代理字符串中添加了额外的标识“Trident”，就是浏览器渲染引擎的代号。格式变成：

   ```
   Mozilla/4.0 (compatible; MSIE Version; Operating System; Trident/TridentVersion)
   ```

   比如：

   ```
   Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)
   ```

   这个新增的“Trident”是为了让开发者知道什么时候IE8运行兼容模式。在兼容模式下，MSIE的版本会变成7，但Trident的版本不变：

   ```
   Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0)
   ```

   添加这个标识之后，就可以确定浏览器究竟是IE7（没有“Trident”），还是IE8运行在兼容模式。

   IE9稍微升级了一下用户代理字符串的格式。Mozilla的版本增加到了5.0，Trident的版本号也增加到了5.0。IE9的默认用户代理字符串是这样的：

   ```
   Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)
   ```

   如果IE9运行兼容模式，则会恢复旧版的Mozilla和MSIE版本号，但Trident的版本号还是5.0。比如，下面就是IE9运行在IE7兼容模式下的字符串：

   ```
   Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0)
   ```

   所有这些改变都是为了让之前的用户代理检测脚本正常运作，同时还能为新脚本提供额外的信息。
    

4. **Gecko**

   Gecko渲染引擎是Firefox的核心。Gecko最初是作为通用Mozilla浏览器（即后来的Netscape 6）的一部分开发的。有一个针对Netscape 6的用户代理字符串规范，规定了未来的版本应该如何构造这个字符串。新的格式与之前一直沿用到4.![x](https://private.codecogs.com/gif.latex?x)版的格式有了很大出入：

   ```
   Mozilla/MozillaVersion (Platform; Encryption; OS-or-CPU; Language;
     PrereleaseVersion)Gecko/GeckoVersion
     ApplicationProduct/ApplicationProductVersion
   ```

   这个复杂的用户代理字符串包含了不少想法。下表列出了其中每一部分的含义。

   | 字符串                      | 是否必需 | 说明                                                         |
   | :-------------------------- | :------- | :----------------------------------------------------------- |
   | `MozillaVersion`            | 是       | Mozilla版本                                                  |
   | `Platform`                  | 是       | 浏览器所在的平台。可能的值包括Windows、Mac和X11（UNIX XWindows） |
   | `Encryption`                | 是       | 加密能力：U表示128位，I表示40位，N表示无加密                 |
   | `OS-or-CPU`                 | 是       | 浏览器所在的操作系统或计算机处理器类型。如果是Windows平台，则这里是Windows的版本（如WinNT、Win95）。如果是Mac平台，则这里是CPU类型（如68k、PPC for PowerPC或MacIntel）。如果是X11平台，则这里是通过`uname -sm`命名得到的UNIX操作系统名 |
   | `Language`                  | 是       | 浏览器的目标使用语言                                         |
   | `Prerelease Version`        | 否       | 最初的设想是Mozilla预发布版的版本号，现在表示Gecko引擎的版本号 |
   | `GeckoVersion`              | 是       | 以yyyymmdd格式的日期表示的Gecko渲染引擎的版本                |
   | `ApplicationProduct`        | 否       | 使用Gecko的产品名称。可能是Netscape、Firefox等               |
   | `ApplicationProductVersion` | 否       | ApplicationProduct的版本，区别于MozillaVersion和GeckoVersion |

   要更好地理解Gecko的用户代理字符串，最好是看几个不同的基于Gecko的浏览器返回的字符串。

   Windowx XP上的Netscape 6.21：

   ```
   Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:0.9.4) Gecko/20011128
     Netscape6/6.2.1
   ```

   Linux上的SeaMonkey 1.1a：

   ```
   Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1b2) Gecko/20060823 SeaMonkey/1.1a
   ```

   Windows XP上的Firefox 2.0.0.11：

   ```
   Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127
     Firefox/2.0.0.11
   ```

   Mac OS X上的Camino 1.5.1：

   ```
   Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809
     Camino/1.5.1
   ```

   所有这些字符串都表示使用的是基于Gecko的浏览器（只是版本不同）。有时候，相比于知道特定的浏览器，知道是不是基于Gecko才更重要。从第一个基于Gecko的浏览器发布开始，Mozilla版本就是5.0，一直没有变过。以后也不太可能会变。

   在Firefox 4发布时，Mozilla简化了用户代理字符串。主要变化包括以下几方面。

   - 去掉了语言标记（即前面例子中的`"en-US"`）。
   - 在浏览器使用强加密时去掉加密标记（因为是默认了）。这意味着`I`和`N`还可能出现，但`U`不可能出现了。
   - 去掉了Windows平台上的平台标记，这是因为跟OS-or-CPU部分重复了，否则两个地方都会有`Windows`。
   - GeckoVersion固定为`"Gecko/20100101"`。

   下面是Firefox 4中用户代理字符串的例子：

   ```
   Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox 4.0.1
   ```

    

5. **WebKit**

   2003年，苹果宣布将发布自己的浏览器Safari。Safari的渲染引擎叫WebKit，是基于Linux平台浏览器Konqueror使用的渲染引擎KHTML开发的。几年后，WebKit又分叉出自己的开源项目，专注于渲染引擎开发。

   这个新浏览器和渲染引擎的开发者也面临与当初IE3.0时代同样的问题：怎样才能保证浏览器不被排除在流行的站点之外。答案就是在用户代理字符串中添加足够多的信息，让网站知道这个浏览器与其他浏览器是兼容的。于是Safari就有了下面这样的用户代理字符串：

   ```
   Mozilla/5.0 (Platform; Encryption; OS-or-CPU; Language)
     AppleWebKit/AppleWebKitVersion (KHTML, like Gecko) Safari/SafariVersion
   ```

   下面是一个实际的例子：

   ```
   Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/124 (KHTML, like Gecko)
     Safari/125.1
   ```

   这个字符串也很长，不仅包括苹果WebKit的版本，也包含Safari的版本。一开始还有是否需要将浏览器标识为Mozilla的争论，但考虑到兼容性很快就达成了一致。现在，所有基于WebKit的浏览器都将自己标识为Mozilla 5.0，与所有基于Gecko的浏览器一样。Safari版本通常是浏览器的构建编号，不一定表示发布的版本号。比如Safari 1.25在用户代理字符串中的版本是125.1，但也不一定始终这样对应。

   Safari用户代理字符串中最受争议的部分是在1.0预发布版中添加的`"(KHTML, like Gecko)"`。由于有意想让客户端和服务器把Safari当成基于Gecko的浏览器（好像光添加`"Mozilla/5.0"`还不够），苹果也招来了很多开发者的反对。苹果的回应与微软当初IE遭受质疑时一样：Safari与Mozilla兼容，不能让网站以为用户使用了不受支持的浏览器而把Safari排斥在外。

   Safari的用户代理字符串在第3版时有所改进。下面的版本标记现在用来表示Safari实际的版本号：

   ```
   Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.15.5
     (KHTML, like Gecko) Version/3.0.3 Safari/522.15.5
   ```

   注意这个变化只针对Safari而不包括WebKit。因此，其他基于WebKit的浏览器可能不会有这个变化。一般来说，与Gecko一样，通常识别是不是WebKit比识别是不是Safari更重要。
    

6. **Konqueror**

   Konqueror是与KDE Linux桌面环境打包发布的浏览器，基于开源渲染引擎KHTML。虽然只有Linux平台的版本，Konqueror的用户却不少。为实现最大化兼容，Konqueror决定采用Internet Explore的用户代理字符串格式：

   ```
   Mozilla/5.0 (compatible; Konqueror/Version; OS-or-CPU)
   ```

   不过，Konqueror 3.2为了与WebKit就标识为KHTML保持一致，也对格式做了一点修改：

   ```
   Mozilla/5.0 (compatible; Konqueror/Version; OS-or-CPU) KHTML/KHTMLVersion
     (like Gecko)
   ```

   下面是一个例子：

   ```
   Mozilla/5.0 (compatible; Konqueror/3.5; SunOS) KHTML/3.5.0 (like Gecko)
   ```

   Konqueror和KHTML的版本号通常是一致的，有时候也只有子版本号不同。比如Konqueror是3.5，而KHTML是3.5.1。
    

7. **Chrome**

   谷歌的Chrome浏览器使用Blink作为渲染引擎，使用V8作为JavaScript引擎。Chrome的用户代理字符串包含所有WebKit的信息，另外又加上了Chrome及其版本的信息。其格式如下所示：

   ```
   Mozilla/5.0 (Platform; Encryption; OS-or-CPU; Language)
     AppleWebKit/AppleWebKitVersion (KHTML, like Gecko)
     Chrome/ChromeVersion Safari/SafariVersion
   ```

   以下是Chrome 7完整的用户代理字符串：

   ```
   Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7
     (KHTML, like Gecko) Chrome/7.0.517.44 Safari/534.7
   ```

   其中的Safari版本和WebKit版本有可能始终保持一致，但也不能肯定。
    

8. **Opera**

   在用户代理字符串方面引发争议最大的一个浏览器就是Opera。Opera默认的用户代理字符串是所有现代浏览器中最符合逻辑的，因为它正确标识了自己和版本。在Opera 8之前，其用户代理字符串都是这个格式：

   ```
   Opera/Version (OS-or-CPU; Encryption) [Language]
   ```

   比如，Windows XP上的Opera 7.54的字符串是这样的：

   ```
   Opera/7.54 (Windows NT 5.1; U) [en]
   ```

   Opera 8发布后，语言标记从括号外挪到了括号内，目的是与其他浏览器保持一致：

   ```
   Opera/Version (OS-or-CPU; Encryption; Language)
   ```

   Windows XP上的Opera 8的字符串是这样的：

   ```
   Opera/8.0 (Windows NT 5.1; U; en)
   ```

   默认情况下，Opera会返回这个简单的用户代理字符串。这是唯一一个使用产品名称和版本完全标识自身的主流浏览器。不过，与其他浏览器一样，Opera也遇到了使用这种字符串的问题。虽然从技术角度看这是正确的，但网上已经有了很多浏览器检测代码只考虑Mozilla这个产品名称。还有不少代码专门针对IE或Gecko。为了不让这些检测代码判断错误，Opera坚持使用唯一标识自身的字符串。

   从Opera 9开始，Opera也采用了两个策略改变自己的字符串。一是把自己标识为别的浏览器，如Firefox或IE。这时候的字符串跟Firefox和IE的一样，只不过末尾会多一个`"Opera"`及其版本号。比如：

   ```
   Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0
     Opera 9.50
   
   Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50
   ```

   第一个字符串把Opera 9.5标识为Firefox 2，同时保持了Opera版本信息。第二个字符串把Opera 9.5标识为IE6，也保持了Opera版本信息。虽然这些字符串可以通过针对Firefox和IE的测试，但也可以被识别为Opera。

   另一个策略是伪装成Firefox或IE。这种情况下的用户代理字符串与Firefox和IE返回的一样，末尾也没有`"Opera"`及其版本信息。这样就根本没办法区分Opera与其他浏览器了。更严重的是，Opera还会根据访问的网站不同设置不同的用户代理字符串，却不通知用户。比如，导航到My Yahoo网站会导致Opera将自己伪装成Firefox。这就导致很难通过用户代理字符串来识别Opera。

   > **注意**　在Opera 7之前的版本中，Opera可以解析Windows操作系统字符串的含义。比如，Windows NT 5.1实际上表示Windows XP。因此Opera 6的用户代理字符串中会包含Windows XP而不是Windows NT 5.1。为了与其他浏览器表现更一致，Opera 7及后来的版本就改为使用官方报告的操作系统字符串，而不是自己转换的了。

   Opera 10又修改了字符串格式，变成了下面这样：

   ```
   Opera/9.80 (OS-or-CPU; Encryption; Language) Presto/PrestoVersion Version/Version
   ```

   注意开头的版本号`Opera/9.80`是固定不变的。Opera没有9.8这个版本，但Opera工程师担心某些浏览器检测脚本会错误地把Opera/10.0当成Opera 1而不是Opera 10。因此，Opera 10新增了额外的Presto标识（Presto是Opera的渲染引擎）和版本标识。比如，下面是Windows 7上的Opera 10.63的字符串：

   ```
   Opera/9.80 (Windows NT 6.1; U; en) Presto/2.6.30 Version/10.63
   ```

   Opera最近的版本已经改为在更标准的字符串末尾追加`"OPR"`标识符和版本号。这样，除了末尾的`"OPR"`标识符和版本号，字符串的其他部分与WebKit浏览器是类似的。下面就是Windows 10上的Opera 52的用户代理字符串：

   ```
   Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
   Chrome/65.0.3325.181 Safari/537.36 OPR/52.0.2871.64
   ```

    

9. **iOS与Android**

   iOS和Android移动操作系统上默认的浏览器都是基于WebKit的，因此具有与相应桌面浏览器一样的用户代理字符串。iOS设备遵循以下基本格式：

   ```
   Mozilla/5.0 (Platform; Encryption; OS-or-CPU like Mac OS X; Language)
     AppleWebKit/AppleWebKitVersion (KHTML, like Gecko) Version/BrowserVersion
     Mobile/MobileVersion Safari/SafariVersion
   ```

   注意其中用于辅助判断Mac操作系统的`"like Mac OS X"`和`"Mobile"`相关的标识。这里的Mobile标识除了说明这是移动WebKit之外并没有什么用。平台可能是`"iPhone"`、`"iPod"`或`"iPad"`，因设备而异。例如：

   ```
   Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us)
     AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16
   ```

   注意在iOS 3以前，操作系统的版本号不会出现在用户代理字符串中。

   默认的Android浏览器通常与iOS上的浏览器格式相同，只是没有`Mobile`后面的版本号（`"Mobile"`标识还有）。例如：

   ```
   Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91)
     AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1
   ```

   这个用户代理字符串是谷歌Nexus One手机上的默认浏览器的。不过，其他Android设备上的浏览器也遵循相同的模式。

### 13.2.2　浏览器分析

想要知道自己代码运行在什么浏览器上，大部分开发者会分析`window.navigator.userAgent`返回的字符串值。所有浏览器都会提供这个值，如果相信这些返回值并基于给定的一组浏览器检测这个字符串，最终会得到关于浏览器和操作系统的比较精确的结果。

相比于能力检测，用户代理检测还是有一定优势的。能力检测可以保证脚本不必理会浏览器而正常执行。现代浏览器用户代理字符串的过去、现在和未来格式都是有章可循的，我们能够利用它们准确识别浏览器。

1. **伪造用户代理**

   通过检测用户代理来识别浏览器并不是完美的方式，毕竟这个字符串是可以造假的。只不过实现`window.navigator`对象的浏览器（即所有现代浏览器）都会提供`userAgent`这个只读属性。因此，简单地给这个属性设置其他值不会有效：

   ```
   console.log(window.navigator.userAgent);
   // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
   Chrome/65.0.3325.181 Safari/537.36
   
   window.navigator.userAgent = 'foobar';
   
   console.log(window.navigator.userAgent);
   // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
   Chrome/65.0.3325.181 Safari/537.36
   ```

   不过，通过简单的办法可以绕过这个限制。比如，有些浏览器提供伪私有的`__defineGetter__`方法，利用它可以篡改用户代理字符串：

   ```
   console.log(window.navigator.userAgent);
   // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
   Chrome/65.0.3325.181 Safari/537.36
   
   window.navigator.__defineGetter__('userAgent', () => 'foobar');
   
   console.log(window.navigator.userAgent);
   // foobar
   ```

   对付这种造假是一件吃力不讨好的事。检测用户代理是否以这种方式被篡改过是可能的，但总体来看还是一场猫捉老鼠的游戏。

   与其劳心费力检测造假，不如更好地专注于浏览器识别。如果相信浏览器返回的用户代理字符串，那就可以用它来判断浏览器。如果怀疑脚本或浏览器可能篡改这个值，那最好还是使用能力检测。
    

2. **分析浏览器**

   通过解析浏览器返回的用户代理字符串，可以极其准确地推断出下列相关的环境信息：

   - 浏览器
   - 浏览器版本
   - 浏览器渲染引擎
   - 设备类型（桌面/移动）
   - 设备生产商
   - 设备型号
   - 操作系统
   - 操作系统版本

   当然，新浏览器、新操作系统和新硬件设备随时可能出现，其中很多可能有着类似但并不相同的用户代理字符串。因此，用户代理解析程序需要与时俱进，频繁更新，以免落伍。自己手写的解析程序如果不及时更新或修订，很容易就过时了。本书上一版写过一个用户代理解析程序，但这一版并不推荐读者自己从头再写一个。相反，这里推荐一些GitHub上维护比较频繁的第三方用户代理解析程序：

   - Bowser
   - UAParser.js
   - Platform.js
   - CURRENT-DEVICE
   - Google Closure
   - Mootools

   > **注意**　Mozilla维基有一个页面“Compatibility/UADetectionLibraries”，其中提供了用户代理解析程序的列表，可以用来识别Mozilla浏览器（甚至所有主流浏览器）。这些解析程序是按照语言分组的。这个页面好像维护不频繁，但其中给出了所有主流的解析库。（注意JavaScript部分包含客户端库和Node.js库。）GitHub上的文章“Are We Detectable Yet?”中还有一张可视化的表格，能让我们对这些库的检测能力一目了然。

## 13.3　软件与硬件检测

现代浏览器提供了一组与页面执行环境相关的信息，包括浏览器、操作系统、硬件和周边设备信息。这些属性可以通过暴露在`window.navigator`上的一组API获得。不过，这些API的跨浏览器支持还不够好，远未达到标准化的程度。

> **注意**　**强烈**建议在使用这些API之前先检测它们是否存在，因为其中多数都不是强制性的，且很多浏览器没有支持。另外，本节介绍的特性有时候不一定可靠。

### 13.3.1　识别浏览器与操作系统

特性检测和用户代理字符串解析是当前常用的两种识别浏览器的方式。而`navigator`和`screen`对象也提供了关于页面所在软件环境的信息。

1. **`navigator.oscpu`**

   `navigator.oscpu`属性是一个字符串，通常对应用户代理字符串中操作系统/系统架构相关信息。根据HTML实时标准：

   > `oscpu`属性的获取方法必须返回空字符串或者表示浏览器所在平台的字符串，比如`"Windows NT 10.0; Win64; x64"`或`"Linux x86_64"`。

   比如，Windows 10上的Firefox的`oscpu`属性应该对应于以下加粗的部分：

   ```
   console.log(navigator.userAgent);
   "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0"
   console.log(navigator.oscpu);
   "Windows NT 10.0; Win64; x64"
   ```

    

2. **`navigator.vendor`**

   `navigator.vendor`属性是一个字符串，通常包含浏览器开发商信息。返回这个字符串是浏览器`navigator`兼容模式的一个功能。根据HTML实时标准：

   > `navigator.vendor`返回一个空字符串，也可能返回字符串`"Apple Computer, Inc."`或字符串`"Google Inc."`。

   例如，Chrome中的这个`navigator.vendor`属性返回下面的字符串：

   ```
   console.log(navigator.vendor); // "Google Inc."
   ```

    

3. **`navigator.platform`**

   `navigator.platform`属性是一个字符串，通常表示浏览器所在的操作系统。根据HTML实时标准：

   > `navigator.platform`必须返回一个字符串或表示浏览器所在平台的字符串，例如`"MacIntel"`、`"Win32"`、`"FreeBSD i386"`或`"WebTV OS"`。

   例如，Windows系统下Chrome中的这个`navigator.platform`属性返回下面的字符串：

   ```
   console.log(navigator.platform); // "Win32"
   ```

    

4. **`screen.colorDepth`和`screen.pixelDepth`**

   `screen.colorDepth`和`screen.pixelDepth`返回一样的值，即显示器每像素颜色的位深。根据CSS对象模型（CSSOM）规范：

   > `screen.colorDepth`和`screen.pixelDepth`属性应该返回输出设备中每像素用于显示颜色的位数，不包含alpha通道。

   Chrome中这两个属性的值如下所示：

   ```
   console.log(screen.colorDepth); // 24
   console.log(screen.pixelDepth); // 24
   ```

    

5. **`screen.orientation`**

   `screen.orientation`属性返回一个`ScreenOrientation`对象，其中包含Screen Orientation API定义的屏幕信息。这里面最有意思的属性是`angle`和`type`，前者返回相对于默认状态下屏幕的角度，后者返回以下4种枚举值之一：

   - `portrait-primary`
   - `portrait-secondary`
   - `landscape-primary`
   - `landscape-secondary`

   例如，在Chrome移动版中，`screen.orientation`返回的信息如下：

   ```
   // 垂直看
   console.log(screen.orientation.type);   // portrait-primary
   console.log(screen.orientation.angle);  // 0
   
   // 向左转
   console.log(screen.orientation.type);   // landscape-primary
   console.log(screen.orientation.angle);  // 90
   
   // 向右转
   console.log(screen.orientation.type);   // landscape-secondary
   console.log(screen.orientation.angle);  // 270
   ```

   根据规范，这些值的初始化取决于浏览器和设备状态。因此，不能假设`portrait-primary`和`0`始终是初始值。这两个值主要用于确定设备旋转后浏览器的朝向变化。

### 13.3.2　浏览器元数据

`navigator`对象暴露出一些API，可以提供浏览器和操作系统的状态信息。

1. **Geolocation API**

   `navigator.geolocation`属性暴露了Geolocation API，可以让浏览器脚本感知当前设备的地理位置。这个API只在安全执行环境（通过HTTPS获取的脚本）中可用。

   这个API可以查询宿主系统并尽可能精确地返回设备的位置信息。根据宿主系统的硬件和配置，返回结果的精度可能不一样。手机GPS的坐标系统可能具有极高的精度，而IP地址的精度就要差很多。根据Geolocation API规范：

   ```
   地理位置信息的主要来源是GPS和IP地址、射频识别（RFID）、Wi-Fi及蓝牙Mac地址、GSM/CDMA蜂窝ID以及用户输入等信息。
   ```

   > **注意**　浏览器也可能会利用Google Location Service（Chrome和Firefox）等服务确定位置。有时候，你可能会发现自己并没有GPS，但浏览器给出的坐标却非常精确。浏览器会收集所有可用的无线网络，包括Wi-Fi和蜂窝信号。拿到这些信息后，再去查询网络数据库。这样就可以精确地报告出你的设备位置。

   要获取浏览器当前的位置，可以使用`getCurrentPosition()`方法。这个方法返回一个`Coordinates`对象，其中包含的信息不一定完全依赖宿主系统的能力：

   ```
   // getCurrentPosition()会以position对象为参数调用传入的回调函数
   navigator.geolocation.getCurrentPosition((position) => p = position);
   ```

   这个`position`对象中有一个表示查询时间的时间戳，以及包含坐标信息的`Coordinates`对象：

   ```
   console.log(p.timestamp);  // 1525364883361
   console.log(p.coords);     // Coordinates {...}
   ```

   `Coordinates`对象中包含标准格式的经度和纬度，以及以米为单位的精度。精度同样以确定设备位置的机制来判定。

   ```
   console.log(p.coords.latitude, p.coords.longitude);   // 37.4854409, -122.2325506
   console.log(p.coords.accuracy);                       // 58
   ```

   `Coordinates`对象包含一个`altitude`（海拔高度）属性，是相对于1984世界大地坐标系（World Geodetic System，1984）地球表面的以米为单位的距离。此外也有一个`altitudeAccuracy`属性，这个精度值单位也是米。为了取得`Coordinates`中包含的这些信息，当前设备必须具备相应的能力（比如GPS或高度计）。很多设备因为没有能力测量高度，所以这两个值经常有一个或两个是空的。

   ```
   console.log(p.coords.altitude);          // -8.800000190734863
   console.log(p.coords.altitudeAccuracy);  // 200
   ```

   `Coordinates`对象包含一个`speed`属性，表示设备每秒移动的速度。还有一个`heading`（朝向）属性，表示相对于正北方向移动的角度（0 ≤ `heading` < 360）。为获取这些信息，当前设备必须具备相应的能力（比如加速计或指南针）。很多设备因为没有能力测量高度，所以这两个值经常有一个是空的，或者两个都是空的。

   > **注意**　设备不会根据两点的向量来测量速度和朝向。不过，如果可能的话，可以尝试基于两次连续的测量数据得到的向量来手动计算。当然，如果向量的精度不够，那么计算结果的精度肯定也不够。

   获取浏览器地理位置并不能保证成功。因此`getCurrentPosition()`方法也接收失败回调函数作为第二个参数，这个函数会收到一个`PositionError`对象。在失败的情况下，`PositionError`对象中会包含一个`code`属性和一个`message`属性，后者包含对错误的简短描述。`code`属性是一个整数，表示以下3种错误。

   - `PERMISSION_DENIED`：浏览器未被允许访问设备位置。页面第一次尝试访问Geolocation API时，浏览器会弹出确认对话框取得用户授权（每个域分别获取）。如果返回了这个错误码，则要么是用户不同意授权，要么是在不安全的环境下访问了Geolocation API。`message`属性还会提供额外信息。
   - `POSITION_UNAVAILABLE`：系统无法返回任何位置信息。这个错误码可能代表各种失败原因，但相对来说并不常见，因为只要设备能上网，就至少可以根据IP地址返回一个低精度的坐标。
   - `TIMEOUT`：系统不能在超时时间内返回位置信息。关于如何配置超时，会在后面介绍。

   ```
   // 浏览器会弹出确认对话框请用户允许访问Geolocation API
   // 这个例子显示了用户拒绝之后的结果
   navigator.geolocation.getCurrentPosition(
     () => {},
     (e) => {
       console.log(e.code);     // 1
       console.log(e.message);  // User denied Geolocation
     }
   );
   
   // 这个例子展示了在不安全的上下文中执行代码的结果
   navigator.geolocation.getCurrentPosition(
     () => {},
     (e) => {
       console.log(e.code);     // 1
       console.log(e.message);  // Only secure origins are allowed
     }
   );
   ```

   Geolocation API位置请求可以使用`PositionOptions`对象来配置，作为第三个参数提供。这个对象支持以下3个属性。

   - `enableHighAccuracy`：布尔值，`true`表示返回的值应该尽量精确，默认值为`false`。默认情况下，设备通常会选择最快、最省电的方式返回坐标。这通常意味着返回的是不够精确的坐标。比如，在移动设备上，默认位置查询通常只会采用Wi-Fi和蜂窝网络的定位信息。而在`enableHighAccuracy`为`true`的情况下，则会使用设备的GPS确定设备位置，并返回这些值的混合结果。使用GPS会更耗时、耗电，因此在使用`enableHighAccuracy`配置时要仔细权衡一下。
   - `timeout`：毫秒，表示在以`TIMEOUT`状态调用错误回调函数之前等待的最长时间。默认值是0xFFFFFFFF（![2^{32}-1](https://private.codecogs.com/gif.latex?2^{32}-1)）。0表示完全跳过系统调用而立即以`TIMEOUT`调用错误回调函数。
   - `maximumAge`：毫秒，表示返回坐标的最长有效期，默认值为0。因为查询设备位置会消耗资源，所以系统通常会缓存坐标并在下次返回缓存的值（遵从位置缓存失效策略）。系统会计算缓存期，如果Geolocation API请求的配置要求比缓存的结果更新，则系统会重新查询并返回值。0表示强制系统忽略缓存的值，每次都重新查询。而`Infinity`会阻止系统重新查询，只会返回缓存的值。JavaScript可以通过检查`Position`对象的`timestamp`属性值是否重复来判断返回的是不是缓存值。
      

2. **Connection State和NetworkInformation API**

   浏览器会跟踪网络连接状态并以两种方式暴露这些信息：连接事件和`navigator.onLine`属性。在设备连接到网络时，浏览器会记录这个事实并在`window`对象上触发`online`事件。相应地，当设备断开网络连接后，浏览器会在`window`对象上触发`offline`事件。任何时候，都可以通过`navigator.onLine`属性来确定浏览器的联网状态。这个属性返回一个布尔值，表示浏览器是否联网。

   ```
   const connectionStateChange = () => console.log(navigator.onLine);
   
   window.addEventListener('online', connectionStateChange);
   window.addEventListener('offline', connectionStateChange);
   
   // 设备联网时：
   // true
   
   // 设备断网时：
   // false
   ```

   当然，到底怎么才算联网取决于浏览器与系统实现。有些浏览器可能会认为只要连接到局域网就算“在线”，而不管是否真正接入了互联网。

   `navigator`对象还暴露了NetworkInformation API，可以通过`navigator.connection`属性使用。这个API提供了一些只读属性，并为连接属性变化事件处理程序定义了一个事件对象。

   以下是NetworkInformation API暴露的属性。

   - `downlink`：整数，表示当前设备的带宽（以Mbit/s为单位），舍入到最接近的25kbit/s。这个值可能会根据历史网络吞吐量计算，也可能根据连接技术的能力来计算。

   - `downlinkMax`：整数，表示当前设备最大的下行带宽（以Mbit/s为单位），根据网络的第一跳来确定。因为第一跳不一定反映端到端的网络速度，所以这个值只能用作粗略的上限值。

   - ```
     effectiveType
     ```

     ：字符串枚举值，表示连接速度和质量。这些值对应不同的蜂窝数据网络连接技术，但也用于分类无线网络。这个值有以下4种可能。

     - ```
       slow-2g
       ```

       - 往返时间 ＞ 2000ms
       - 下行带宽 ＜ 50kbit/s

     - ```
       2g
       ```

       - 2000ms ＞ 往返时间 ≥ 1400ms
       - 70kbit/s ＞ 下行带宽 ≥ 50kbit/s

     - ```
       3g
       ```

       - 1400ms ＞ 往返时间 ≥ 270ms
       - 700kbit/s ＞ 下行带宽 ≥ 70kbit/s

     - ```
       4g
       ```

       - 270ms ＞ 往返时间 ≥ 0ms
       - 下行带宽 ≥ 700kbit/s

   - `rtt`：毫秒，表示当前网络实际的往返时间，舍入为最接近的25毫秒。这个值可能根据历史网络吞吐量计算，也可能根据连接技术的能力来计算。

   - ```
     type
     ```

     ：字符串枚举值，表示网络连接技术。这个值可能为下列值之一。

     - `bluetooth`：蓝牙。
     - `cellular`：蜂窝。
     - `ethernet`：以太网。
     - `none`：无网络连接。相当于`navigator.onLine === false`。
     - `mixed`：多种网络混合。
     - `other`：其他。
     - `unknown`：不确定。
     - `wifi`：Wi-Fi。
     - `wimax`：WiMAX。

   - `saveData`：布尔值，表示用户设备是否启用了“节流”（reduced data）模式。

   - `onchange`：事件处理程序，会在任何连接状态变化时激发一个`change`事件。可以通过`navigator.connection.addEventListener('change',changeHandler)`或`navigator.connection.onchange = changeHandler`等方式使用。
      

3. **Battery Status API**

   浏览器可以访问设备电池及充电状态的信息。`navigator.getBattery()`方法会返回一个期约实例，解决为一个`BatteryManager`对象。

   ```
   navigator.getBattery().then((b) => console.log(b));
   // BatteryManager { ... }
   ```

   `BatteryManager`包含4个只读属性，提供了设备电池的相关信息。

   - `charging`：布尔值，表示设备当前是否正接入电源充电。如果设备没有电池，则返回`true`。
   - `chargingTime`：整数，表示预计离电池充满还有多少秒。如果电池已充满或设备没有电池，则返回0。
   - `dischargingTime`：整数，表示预计离电量耗尽还有多少秒。如果设备没有电池，则返回`Infinity`。
   - `level`：浮点数，表示电量百分比。电量完全耗尽返回0.0，电池充满返回1.0。如果设备没有电池，则返回1.0。

   这个API还提供了4个事件属性，可用于设置在相应的电池事件发生时调用的回调函数。可以通过给`BatteryManager`添加事件监听器，也可以通过给事件属性赋值来使用这些属性。

   - `onchargingchange`
   - `onchargingtimechange`
   - `ondischargingtimechange`
   - `onlevelchange`

   ```
   navigator.getBattery().then((battery) => {
     // 添加充电状态变化时的处理程序
     const chargingChangeHandler = () => console.log('chargingchange');
     battery.onchargingchange = chargingChangeHandler;
     // 或
     battery.addEventListener('chargingchange', chargingChangeHandler);
   
     // 添加充电时间变化时的处理程序
     const chargingTimeChangeHandler = () => console.log('chargingtimechange');
     battery.onchargingtimechange = chargingTimeChangeHandler;
     // 或
     battery.addEventListener('chargingtimechange', chargingTimeChangeHandler);
   
     // 添加放电时间变化时的处理程序
     const dischargingChangeHandler = () => console.log('dischargingtimechange');
     battery.ondischargingtimechange = dischargingTimeChangeHandler;
     // 或
     battery.addEventListener('dischargingtimechange', dischargingTimeChangeHandler);
   
     // 添加电量百分比变化时的处理程序
     const levelChangeHandler = () => console.log('levelchange');
     battery.onlevelchange = levelChangeHandler;
     // 或
     battery.addEventListener('levelchange', levelChangeHandler);
   });
   ```

### 13.3.3　硬件

浏览器检测硬件的能力相当有限。不过，`navigator`对象还是通过一些属性提供了基本信息。

1. **处理器核心数**

   `navigator.hardwareConcurrency`属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值（如果核心数无法确定，这个值就是1）。关键在于，这个值表示浏览器可以并行执行的最大工作线程数量，不一定是实际的CPU核心数。
    

2. **设备内存大小**

   `navigator.deviceMemory`属性返回设备大致的系统内存大小，包含单位为GB的浮点数（舍入为最接近的2的幂：512MB返回0.5，4GB返回4）。
    

3. **最大触点数**

   `navigator.maxTouchPoints`属性返回触摸屏支持的最大关联触点数量，包含一个整数值。

## 13.4　小结

客户端检测是JavaScript中争议最多的话题之一。因为不同浏览器之间存在差异，所以经常需要根据浏览器的能力来编写不同的代码。客户端检测有不少方式，但下面两种用得最多。

- **能力检测**，在使用之前先测试浏览器的特定能力。例如，脚本可以在调用某个函数之前先检查它是否存在。这种客户端检测方式可以让开发者不必考虑特定的浏览器或版本，而只需关注某些能力是否存在。能力检测不能精确地反映特定的浏览器或版本。
- **用户代理检测**，通过用户代理字符串确定浏览器。用户代理字符串包含关于浏览器的很多信息，通常包括浏览器、平台、操作系统和浏览器版本。用户代理字符串有一个相当长的发展史，很多浏览器都试图欺骗网站相信自己是别的浏览器。用户代理检测也比较麻烦，特别是涉及Opera会在代理字符串中隐藏自己信息的时候。即使如此，用户代理字符串也可以用来确定浏览器使用的渲染引擎以及平台，包括移动设备和游戏机。

在选择客户端检测方法时，首选是使用能力检测。特殊能力检测要放在次要位置，作为决定代码逻辑的参考。用户代理检测是最后一个选择，因为它过于依赖用户代理字符串。

浏览器也提供了一些软件和硬件相关的信息。这些信息通过`screen`和`navigator`对象暴露出来。利用这些API，可以获取关于操作系统、浏览器、硬件、设备位置、电池状态等方面的准确信息。

## 第 14 章　DOM

> **本章内容**
>
> - 理解文档对象模型（DOM）的构成
> - 节点类型
> - 浏览器兼容性
> - `MutationObserver`接口

文档对象模型（DOM，Document Object Model）是HTML和XML文档的编程接口。DOM表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态HTML（DHTML，Dynamic HTML），DOM现在是真正跨平台、语言无关的表示和操作网页的方式。

DOM Level 1在1998年成为W3C推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍DOM，主要因为它与浏览器中的HTML网页相关，并且在JavaScript中提供了DOM API。

> **注意**　IE8及更低版本中的DOM是通过COM对象实现的。这意味着这些版本的IE中，DOM对象跟原生JavaScript对象具有不同的行为和功能。

## 14.1　节点层级

任何HTML或XML文档都可以用DOM表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。以下面的HTML为例：

```
<html>
  <head>
    <title>Sample Page</title>
  </head>
  <body>
    <p>Hello World!</p>
  </body>
</html>
```

如果表示为层级结构，则如图14-1所示。

![img](http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/021.png)

**图　14-1**

其中，`document`节点表示每个文档的根节点。在这里，根节点的唯一子节点是`<html>`元素，我们称之为**文档元素**（`documentElement`）。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在HTML页面中，文档元素始终是`<html>`元素。在XML文档中，则没有这样预定义的元素，任何元素都可能成为文档元素。

HTML中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM中总共有12种节点类型，这些类型都继承一种基本类型。

### 14.1.1　`Node`类型

DOM Level 1描述了名为`Node`的接口，这个接口是所有DOM节点类型都必须实现的。`Node`接口在JavaScript中被实现为`Node`类型，在除IE之外的所有浏览器中都可以直接访问这个类型。在JavaScript中，所有节点类型都继承`Node`类型，因此所有类型都共享相同的基本属性和方法。

每个节点都有`nodeType`属性，表示该节点的类型。节点类型由定义在`Node`类型上的12个数值常量表示：

- `Node.ELEMENT_NODE`（1）
- `Node.ATTRIBUTE_NODE`（2）
- `Node.TEXT_NODE`（3）
- `Node.CDATA_SECTION_NODE`（4）
- `Node.ENTITY_REFERENCE_NODE`（5）
- `Node.ENTITY_NODE`（6）
- `Node.PROCESSING_INSTRUCTION_NODE`（7）
- `Node.COMMENT_NODE`（8）
- `Node.DOCUMENT_NODE`（9）
- `Node.DOCUMENT_TYPE_NODE`（10）
- `Node.DOCUMENT_FRAGMENT_NODE`（11）
- `Node.NOTATION_NODE`（12）

节点类型可通过与这些常量比较来确定，比如：

```
if (someNode.nodeType == Node.ELEMENT_NODE){
  alert("Node is an element.");
}
```

这个例子比较了`someNode.nodeType`与`Node.ELEMENT_NODE`常量。如果两者相等，则意味着someNode是一个元素节点。

浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。

1. **`nodeName`与`nodeValue`**

   `nodeName`与`nodeValue`保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示：

   ```
   if (someNode.nodeType == 1){
     value = someNode.nodeName; // 会显示元素的标签名
   }
   ```

   在这个例子中，先检查了节点是不是元素。如果是，则将其`nodeName`的值赋给一个变量。对元素而言，`nodeName`始终等于元素的标签名，而`nodeValue`则始终为`null`。
    

2. **节点关系**

   文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。在HTML中，`<body>`元素是`<html>`元素的子元素，而`<html>`元素则是`<body>`元素的父元素。`<head>`元素是`<body>`元素的同胞元素，因为它们有共同的父元素`<html>`。

   每个节点都有一个`childNodes`属性，其中包含一个`NodeList`的实例。`NodeList`是一个类数组对象，用于存储可以按位置存取的有序节点。注意，`NodeList`并不是`Array`的实例，但可以使用中括号访问它的值，而且它也有`length`属性。`NodeList`对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在`NodeList`中反映出来。我们通常说`NodeList`是实时的活动对象，而不是第一次访问时所获得内容的快照。

   下面的例子展示了如何使用中括号或使用`item()`方法访问`NodeList`中的元素：

   ```
   let firstChild = someNode.childNodes[0];
   let secondChild = someNode.childNodes.item(1);
   let count = someNode.childNodes.length;
   ```

   无论是使用中括号还是`item()`方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个类数组对象。注意，`length`属性表示那一时刻`NodeList`中节点的数量。使用`Array.prototype.slice()`可以像前面介绍`arguments`时一样把`NodeList`对象转换为数组。比如：

   ```
   let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);
   ```

   当然，使用ES6的`Array.from()`静态方法，可以替换这种笨拙的方式：

   ```
   let arrayOfNodes = Array.from(someNode.childNodes);
   ```

   每个节点都有一个`parentNode`属性，指向其DOM树中的父元素。`childNodes`中的所有节点都有同一个父元素，因此它们的`parentNode`属性都指向同一个节点。此外，`childNodes`列表中的每个节点都是同一列表中其他节点的同胞节点。而使用`previousSibling`和`nextSibling`可以在这个列表的节点间导航。这个列表中第一个节点的`previousSibling`属性是`null`，最后一个节点的`nextSibling`属性也是`null`，如下所示：

   ```
   if (someNode.nextSibling === null){
     alert("Last node in the parent's childNodes list.");
   } else if (someNode.previousSibling === null){
     alert("First node in the parent's childNodes list.");
   }
   ```

   注意，如果`childNodes`中只有一个节点，则它的`previousSibling`和`nextSibling`属性都是`null`。

   父节点和它的第一个及最后一个子节点也有专门属性：`firstChild`和`lastChild`分别指向`childNodes`中的第一个和最后一个子节点。`someNode.firstChild`的值始终等于`someNode.childNodes[0]`，而`someNode.lastChild`的值始终等于`someNode.childNodes[someNode.childNodes.length-1]`。如果只有一个子节点，则`firstChild`和`lastChild`指向同一个节点。如果没有子节点，则`firstChild`和`lastChild`都是`null`。上述这些节点之间的关系为在文档树的节点之间导航提供了方便。图14-2形象地展示了这些关系。

   ![img](http://www.ituring.com.cn/figures/2020/JavaScriptWebDeve4th/022.png)

   **图　14-2**

   有了这些关系，`childNodes`属性的作用远远不止是必备属性那么简单了。这是因为利用这些关系指针，几乎可以访问到文档树中的任何节点，而这种便利性是`childNodes`的最大亮点。还有一个便利的方法是`hasChildNodes()`，这个方法如果返回`true`则说明节点有一个或多个子节点。相比查询`childNodes`的`length`属性，这个方法无疑更方便。

   最后还有一个所有节点都共享的关系。`ownerDocument`属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能同时存在于两个或者多个文档中。这个属性为迅速访问文档节点提供了便利，因为无需在文档结构中逐层上溯了。

   > **注意**　虽然所有节点类型都继承了`Node`，但并非所有节点都有子节点。本章后面会讨论不同节点类型的差异。

    

3. **操纵节点**

   因为所有关系指针都是只读的，所以DOM又提供了一些操纵节点的方法。最常用的方法是`appendChild()`，用于在`childNodes`列表末尾添加节点。添加新节点会更新相关的关系指针，包括父节点和之前的最后一个子节点。`appendChild()`方法返回新添加的节点，如下所示：

   ```
   let returnedNode = someNode.appendChild(newNode);
   alert(returnedNode == newNode);        // true
   alert(someNode.lastChild == newNode);  // true
   ```

   如果把文档中已经存在的节点传给`appendChild()`，则这个节点会从之前的位置被转移到新位置。即使DOM树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。因此，如果调用`appendChild()`传入父元素的第一个子节点，则这个节点会成为父元素的最后一个子节点，如下所示：

   ```
   // 假设someNode有多个子节点
   let returnedNode = someNode.appendChild(someNode.firstChild);
   alert(returnedNode == someNode.firstChild);  // false
   alert(returnedNode == someNode.lastChild);   // true
   ```

   如果想把节点放到`childNodes`中的特定位置而不是末尾，则可以使用`insertBefore()`方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是`null`，则`insertBefore()`与`appendChild()`效果相同，如下面的例子所示：

   ```
   // 作为最后一个子节点插入
   returnedNode = someNode.insertBefore(newNode, null);
   alert(newNode == someNode.lastChild);  // true
   
   // 作为新的第一个子节点插入
   returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
   alert(returnedNode == newNode);         // true
   alert(newNode == someNode.firstChild);  // true
   
   // 插入最后一个子节点前面
   returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
   alert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); // true
   ```

   `appendChild()`和`insertBefore()`在插入节点时不会删除任何已有节点。相对地，`replaceChild()`方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。下面看一个例子：

   ```
   // 替换第一个子节点
   let returnedNode = someNode.replaceChild(newNode, someNode.firstChild);
   
   // 替换最后一个子节点
   returnedNode = someNode.replaceChild(newNode, someNode.lastChild);
   ```

   使用`replaceChild()`插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。

   要移除节点而不是替换节点，可以使用`removeChild()`方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回，如下面的例子所示：

   ```
   // 删除第一个子节点
   let formerFirstChild = someNode.removeChild(someNode.firstChild);
   
   // 删除最后一个子节点
   let formerLastChild = someNode.removeChild(someNode.lastChild);
   ```

   与`replaceChild()`方法一样，通过`removeChild()`被移除的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。

   上面介绍的4个方法都用于操纵某个节点的子元素，也就是说使用它们之前必须先取得父节点（使用前面介绍的`parentNode`属性）。并非所有节点类型都有子节点，如果在不支持子节点的节点上调用这些方法，则会导致抛出错误。
    

4. **其他方法**

   所有节点类型还共享了两个方法。第一个是`cloneNode()`，会返回与调用它的节点一模一样的节点。`cloneNode()`方法接收一个布尔值参数，表示是否深复制。在传入`true`参数时，会进行深复制，即复制节点及其整个子DOM树。如果传入`false`，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。可以通过`appendChild()`、`insertBefore()`或`replaceChild()`方法把孤儿节点添加到文档中。以下面的HTML片段为例：

   ```
   <ul>
     <li>item 1</li>
     <li>item 2</li>
     <li>item 3</li>
   </ul>
   ```

   如果`myList`保存着对这个`<ul>`元素的引用，则下列代码展示了使用`cloneNode()`方法的两种方式：

   ```
   let deepList = myList.cloneNode(true);
   alert(deepList.childNodes.length);    // 3（IE9之前的版本）或7（其他浏览器）
   
   let shallowList = myList.cloneNode(false);
   alert(shallowList.childNodes.length); // 0
   ```

   在这个例子中，`deepList`保存着`myList`的副本。这意味着`deepList`有3个列表项，每个列表项又各自包含文本。变量`shallowList`则保存着`myList`的浅副本，因此没有子节点。`deepList.childNodes.length`的值会因IE8及更低版本和其他浏览器对空格的处理方式而不同。IE9之前的版本不会为空格创建节点。

   > **注意**　`cloneNode()`方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选地复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是一个bug，所以推荐在复制前先删除事件处理程序。

   本节要介绍的最后一个方法是`normalize()`。这个方法唯一的任务就是处理文档子树中的文本节点。由于解析器实现的差异或DOM操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用`normalize()`方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。这个方法将在本章后面进一步讨论。

### 14.1.2　`Document`类型

`Document`类型是JavaScript中表示文档节点的类型。在浏览器中，文档对象`document`是`HTMLDocument`的实例（`HTMLDocument`继承`Document`），表示整个HTML页面。`document`是`window`对象的属性，因此是一个全局对象。`Document`类型的节点有以下特征：

- `nodeType`等于9；
- `nodeName`值为`"#document"`；
- `nodeValue`值为`null`；
- `parentNode`值为`null`；
- `ownerDocument`值为`null`；
- 子节点可以是`DocumentType`（最多一个）、`Element`（最多一个）、`ProcessingInstruction`或`Comment`类型。

`Document`类型可以表示HTML页面或其他XML文档，但最常用的还是通过`HTMLDocument`的实例取得`document`对象。`document`对象可用于获取关于页面的信息以及操纵其外观和底层结构。

1. **文档子节点**

   虽然DOM规范规定`Document`节点的子节点可以是`DocumentType`、`Element`、`ProcessingInstruction`或`Comment`，但也提供了两个访问子节点的快捷方式。第一个是`documentElement`属性，始终指向HTML页面中的`<html>`元素。虽然`document.childNodes`中始终有`<html>`元素，但使用`documentElement`属性可以更快更直接地访问该元素。假如有以下简单的页面：

   ```
   <html>
     <body>
   
     </body>
   </html>
   ```

   浏览器解析完这个页面之后，文档只有一个子节点，即`<html>`元素。这个元素既可以通过`documentElement`属性获取，也可以通过`childNodes`列表访问，如下所示：

   ```
   let html = document.documentElement;     // 取得对<html>的引用
   alert(html === document.childNodes[0]);  // true
   alert(html === document.firstChild);     // true
   ```

   这个例子表明`documentElement`、 `firstChild`和`childNodes[0]`都指向同一个值，即`<html>`元素。

   作为`HTMLDocument`的实例，`document`对象还有一个`body`属性，直接指向`<body>`元素。因为这个元素是开发者使用最多的元素，所以JavaScript代码中经常可以看到`document.body`，比如：

   ```
   let body = document.body; // 取得对<body>的引用
   ```

   所有主流浏览器都支持`document.documentElement`和`document.body`。

   `Document`类型另一种可能的子节点是`DocumentType`。`<!doctype>`标签是文档中独立的部分，其信息可以通过`doctype`属性（在浏览器中是`document.doctype`）来访问，比如：

   ```
   let doctype = document.doctype; // 取得对<!doctype>的引用
   ```

   另外，严格来讲出现在`<html>`元素外面的注释也是文档的子节点，它们的类型是`Comment`。不过，由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。比如以下HTML页面：

   ```
   <!-- 第一条注释 -->
   <html>
     <body>
   
     </body>
   </html>
   <!-- 第二条注释 -->
   ```

   这个页面看起来有3个子节点：注释、`<html>`元素、注释。逻辑上讲，`document.childNodes`应该包含3项，对应代码中的每个节点。但实际上，浏览器有可能以不同方式对待`<html>`元素外部的注释，比如忽略一个或两个注释。

   一般来说，`appendChild()`、`removeChild()`和`replaceChild()`方法不会用在`document`对象上。这是因为文档类型（如果存在）是只读的，而且只能有一个`Element`类型的子节点（即`<html>`，已经存在了）。**1**
    

2. **文档信息**

   `document`作为`HTMLDocument`的实例，还有一些标准`Document`对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是`title`，包含`<title>`元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改`title`属性并不会改变`<title>`元素。下面是一个例子：

   ```
   // 读取文档标题
   let originalTitle = document.title;
   
   // 修改文档标题
   document.title = "New page title";
   ```

   接下来要介绍的3个属性是`URL`、`domain`和`referrer`。其中，`URL`包含当前页面的完整URL（地址栏中的URL），`domain`包含页面的域名，而`referrer`包含链接到当前页面的那个页面的URL。如果当前页面没有来源，则`referrer`属性包含空字符串。所有这些信息都可以在请求的HTTP头部信息中获取，只是在JavaScript中通过这几个属性暴露出来而已，如下面的例子所示：

   ```
   // 取得完整的URL
   let url = document.URL;
   
   // 取得域名
   let domain = document.domain;
   
   // 取得来源
   let referrer = document.referrer;
   ```

   URL跟域名是相关的。比如，如果`document.URL`是`http://www.wrox.com/WileyCDA/`，则`document.domain`就是`www.wrox.com`。

   在这些属性中，只有`domain`属性是可以设置的。出于安全考虑，给`domain`属性设置的值是有限制的。如果URL包含子域名如`p2p.wrox.com`，则可以将`domain`设置为`"wrox.com"`（URL包含“www”时也一样，比如`www.wrox.com`）。不能给这个属性设置URL中不包含的值，比如：

   ```
   // 页面来自p2p.wrox.com
   
   document.domain = "wrox.com";      // 成功
   
   document.domain = "nczonline.net"; // 出错！
   ```

   当页面中包含来自某个不同子域的窗格（`<frame>`）或内嵌窗格（`<iframe>`）时，设置`document.domain`是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时，在每个页面上把`document.domain`设置为相同的值，这些页面就可以访问对方的JavaScript对象了。比如，一个加载自`www.wrox.com`的页面中包含一个内嵌窗格，其中的页面加载自`p2p.wrox.com`。这两个页面的`document.domain`包含不同的字符串，内部和外部页面相互之间不能访问对方的JavaScript对象。如果每个页面都把`document.domain`设置为`wrox.com`，那这两个页面之间就可以通信了。

   浏览器对`domain`属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把`document.domain` 设置为`"wrox.com"`之后，就不能再将其设置回`"p2p.wrox.com"`，后者会导致错误，比如：

   ```
   // 页面来自p2p.wrox.com
   
   document.domain = "wrox.com";     // 放松，成功
   
   document.domain = "p2p.wrox.com"; // 收紧，错误！
   ```

    

3. **定位元素**

   使用DOM最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。`document`对象上暴露了一些方法，可以实现这些操作。`getElementById()`和`getElementsByTagName()`就是`Document`类型提供的两个方法。

   `getElementById()`方法接收一个参数，即要获取元素的ID，如果找到了则返回这个元素，如果没找到则返回`null`。参数ID必须跟元素在页面中的`id`属性值完全匹配，包括大小写。比如页面中有以下元素：

   ```
   <div id="myDiv">Some text</div>
   ```

   可以使用如下代码取得这个元素：

   ```
   let div = document.getElementById("myDiv"); // 取得对这个<div>元素的引用
   ```

   但参数大小写不匹配会返回`null`：

   ```
   let div = document.getElementById("mydiv"); // null
   ```

   如果页面中存在多个具有相同ID的元素，则`getElementById()`返回在文档中出现的第一个元素。

   `getElementsByTagName()`是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的`NodeList`。在HTML文档中，这个方法返回一个`HTMLCollection`对象。考虑到二者都是“实时”列表，`HTMLCollection`与`NodeList`是很相似的。例如，下面的代码会取得页面中所有的`<img>`元素并返回包含它们的`HTMLCollection`：

   ```
   let images = document.getElementsByTagName("img");
   ```

   这里把返回的`HTMLCollection`对象保存在了变量`images`中。与`NodeList`对象一样，也可以使用中括号或`item()`方法从`HTMLCollection`取得特定的元素。而取得元素的数量同样可以通过`length`属性得知，如下所示：

   ```
   alert(images.length);       // 图片数量
   alert(images[0].src);       // 第一张图片的src属性
   alert(images.item(0).src);  // 同上
   ```

   `HTMLCollection`对象还有一个额外的方法`namedItem()`，可通过标签的`name`属性取得某一项的引用。例如，假设页面中包含如下的`<img>`元素：

   ```
   <img src="myimage.gif" name="myImage">
   ```

   那么也可以像这样从`images`中取得对这个`<img>`元素的引用：

   ```
   let myImage = images.namedItem("myImage");
   ```

   这样，`HTMLCollection`就提供了除索引之外的另一种获取列表项的方式，从而为取得元素提供了便利。对于`name`属性的元素，还可以直接使用中括号来获取，如下面的例子所示：

   ```
   let myImage = images["myImage"];
   ```

   对`HTMLCollection`对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用`item()`，字符串索引会调用`namedItem()`。

   要取得文档中的所有元素，可以给`getElementsByTagName()`传入`*`。在JavaScript和CSS中，`*`一般被认为是匹配一切的字符。来看下面的例子：

   ```
   let allElements = document.getElementsByTagName("*");
   ```

   这行代码可以返回包含页面中所有元素的`HTMLCollection`对象，顺序就是它们在页面中出现的顺序。因此第一项是`<html>`元素，第二项是`<head>`元素，以此类推。

   > **注意**　对于`document.getElementsByTagName()`方法，虽然规范要求区分标签的大小写，但为了最大限度兼容原有HTML页面，实际上是不区分大小写的。如果是在XML页面（如XHTML）中使用，那么`document.getElementsByTagName()`就是区分大小写的。

   `HTMLDocument`类型上定义的获取元素的第三个方法是`getElementsByName()`。顾名思义，这个方法会返回具有给定`name`属性的所有元素。`getElementsByName()`方法最常用于单选按钮，因为同一字段的单选按钮必须具有相同的`name`属性才能确保把正确的值发送给服务器，比如下面的例子：

   ```
   <fieldset>
     <legend>Which color do you prefer?</legend>
     <ul>
       <li>
         <input type="radio" value="red" name="color" id="colorRed">
         <label for="colorRed">Red</label>
       </li>
       <li>
         <input type="radio" value="green" name="color" id="colorGreen">
         <label for="colorGreen">Green</label>
       </li>
       <li>
         <input type="radio" value="blue" name="color" id="colorBlue">
         <label for="colorBlue">Blue</label>
       </li>
     </ul>
   </fieldset>
   ```

   这里所有的单选按钮都有名为`"color"`的`name`属性，但它们的ID都不一样。这是因为ID是为了匹配对应的`<label>`元素，而`name`相同是为了保证只将三个中的一个值发送给服务器。然后就可以像下面这样取得所有单选按钮：

   ```
   let radios = document.getElementsByName("color");
   ```

   与`getElementsByTagName()`一样，`getElementsByName()`方法也返回`HTMLCollection`。不过在这种情况下，`namedItem()`方法只会取得第一项（因为所有项的`name`属性都一样）。
    

4. **特殊集合**

   `document`对象上还暴露了几个特殊集合，这些集合也都是`HTMLCollection`的实例。这些集合是访问文档中公共部分的快捷方式，列举如下。

   - `document.anchors`包含文档中所有带`name`属性的`<a>`元素。
   - `document.applets`包含文档中所有`<applet>`元素（因为`<applet>`元素已经不建议使用，所以这个集合已经废弃）。
   - `document.forms`包含文档中所有`<form>`元素（与`document.getElementsByTagName ("form")`返回的结果相同）。
   - `document.images`包含文档中所有`<img>`元素（与`document.getElementsByTagName ("img")`返回的结果相同）。
   - `document.links`包含文档中所有带`href`属性的`<a>`元素。

   这些特殊集合始终存在于`HTMLDocument`对象上，而且与所有`HTMLCollection`对象一样，其内容也会实时更新以符合当前文档的内容。
    

5. **DOM兼容性检测**

   由于DOM有多个Level和多个部分，因此确定浏览器实现了DOM的哪些部分是很必要的。`document.implementation`属性是一个对象，其中提供了与浏览器DOM实现相关的信息和能力。DOM Level 1在`document.implementation`上只定义了一个方法，即`hasFeature()`。这个方法接收两个参数：特性名称和DOM版本。如果浏览器支持指定的特性和版本，则`hasFeature()`方法返回`true`，如下面的例子所示：

   ```
   let hasXmlDom = document.implementation.hasFeature("XML", "1.0");
   ```

   可以使用`hasFeature()`方法测试的特性及版本如下表所列。

   | 特性                 | 支持的版本    | 说明                                                     |
   | :------------------- | :------------ | :------------------------------------------------------- |
   | `Core`               | 1.0、2.0、3.0 | 定义树形文档结构的基本DOM                                |
   | `XML`                | 1.0、2.0、3.0 | `Core`的XML扩展，增加了对CDATA区块、处理指令和实体的支持 |
   | `HTML`               | 1.0、2.0      | `XML`的HTML扩展，增加了HTML特定的元素和实体              |
   | `Views`              | 2.0           | 文档基于某些样式的实现格式                               |
   | `StyleSheets`        | 2.0           | 文档的相关样式表                                         |
   | `CSS`                | 2.0           | Cascading Style Sheets Level 1                           |
   | `CSS2`               | 2.0           | Cascading Style Sheets Level 2                           |
   | `Events`             | 2.0、3.0      | 通用DOM事件                                              |
   | `UIEvents`           | 2.0、3.0      | 用户界面事件                                             |
   | `TextEvents`         | 3.0           | 文本输入设备触发的事件                                   |
   | `MouseEvents`        | 2.0、3.0      | 鼠标导致的事件（单击、悬停等）                           |
   | `MutationEvents`     | 2.0、3.0      | DOM树变化时触发的事件                                    |
   | `MutationNameEvents` | 3.0           | DOM元素或元素属性被重命名时触发的事件                    |
   | `HTMLEvents`         | 2.0           | HTML 4.01事件                                            |
   | `Range`              | 2.0           | 在DOM树中操作一定范围的对象和方法                        |
   | `Traversal`          | 2.0           | 遍历DOM树的方法                                          |
   | `LS`                 | 3.0           | 文件与DOM树之间的同步加载与保存                          |
   | `LS-Async`           | 3.0           | 文件与DOM树之间的异步加载与保存                          |
   | `Validation`         | 3.0           | 修改DOM树并保证其继续有效的方法                          |
   | `XPath`              | 3.0           | 访问XML文档不同部分的语言                                |

   由于实现不一致，因此`hasFeature()`的返回值并不可靠。目前这个方法已经被废弃，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回`true`。
    

6. **文档写入**

   `document`对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应4个方法：`write()`、`writeln()`、`open()`和`close()`。其中，`write()`和`writeln()`方法都接收一个字符串参数，可以将这个字符串写入网页中。`write()`简单地写入文本，而`writeln()`还会在字符串末尾追加一个换行符（`\n`）。这两个方法可以用来在页面加载期间向页面中动态添加内容，如下所示：

   ```
   <html>
   <head>
     <title>document.write() Example</title>
   </head>
   <body>
     <p>The current date and time is:
     <script type="text/javascript">
       document.write("<strong>" + (new Date()).toString() + "</strong>");
     </script>
   </p>
   </body>
   </html>
   ```

   这个例子会在页面加载过程中输出当前日期和时间。日期放在了`<strong>`元素中，如同它们之前就包含在HTML页面中一样。这意味着会创建一个DOM元素，以后也可以访问。通过`write()`和`writeln()`输出的任何HTML都会以这种方式来处理。

   `write()`和`writeln()`方法经常用于动态包含外部资源，如JavaScript文件。在包含JavaScript文件时，记住不能像下面的例子中这样直接包含字符串`"</script>"`，因为这个字符串会被解释为脚本块的结尾，导致后面的代码不能执行：

   ```
   <html>
   <head>
     <title>document.write() Example</title>
   </head>
   <body>
     <script type="text/javascript">
       document.write("<script type=\"text/javascript\" src=\"file.js\">" +
         "</script>");
     </script>
   </body>
   </html>
   ```

   虽然这样写看起来没错，但输出之后的`"</script>"`会匹配最外层的`<script>`标签，导致页面中显示出`");`。为避免出现这个问题，需要对前面的例子稍加修改：

   ```
   <html>
   <head>
     <title>document.write() Example</title>
   </head>
   <body>
     <script type="text/javascript">
       document.write("<script type=\"text/javascript\" src=\"file.js\">" +
         "<\/script>");
     </script>
   </body>
   </html>
   ```

   这里的字符串`"<\/script>"`不会再匹配最外层的`<script>`标签，因此不会在页面中输出额外内容。

   前面的例子展示了在页面渲染期间通过`document.write()`向文档中输出内容。如果是在页面加载完之后再调用`document.write()`，则输出的内容会重写整个页面，如下面的例子所示：

   ```
   <html>
   <head>
     <title>document.write() Example</title>
   </head>
   <body>
     <p>This is some content that you won't get to see because it will be
     overwritten.</p>
     <script type="text/javascript">
       window.onload = function(){
         document.write("Hello world!");
       };
     </script>
   </body>
   </html>
   ```

   这个例子使用了`window.onload`事件处理程序，将调用`document.write()`的函数推迟到页面加载完毕后执行。执行之后，字符串`"Hello world!"`会重写整个页面内容。

   `open()`和`close()`方法分别用于打开和关闭网页输出流。在调用`write()`和`writeln()`时，这两个方法都不是必需的。

   > **注意**　严格的XHTML文档不支持文档写入。对于内容类型为`application`/`xml`+`xhtml`的页面，这些方法不起作用。

**1**元素是`HTMLHtmlElement`的实例，`HTMLHtmlElement`继承`HTMLElement`，`HTMLElement`继承`Element`，因此HTML文档可以包含子节点，但不能多于一个。——译者注

### 14.1.3　`Element`类型

除了`Document`类型，`Element`类型就是Web开发中最常用的类型了。`Element`表示XML或HTML元素，对外暴露出访问元素标签名、子节点和属性的能力。`Element`类型的节点具有以下特征：

- `nodeType`等于1；
- `nodeName`值为元素的标签名；
- `nodeValue`值为`null`；
- `parentNode`值为`Document`或`Element`对象；
- 子节点可以是`Element`、`Text`、`Comment`、`ProcessingInstruction`、`CDATASection`、`EntityReference`类型。

可以通过`nodeName`或`tagName`属性来获取元素的标签名。这两个属性返回同样的值（添加后一个属性明显是为了不让人误会）。比如有下面的元素：

```
<div id="myDiv"></div>
```

可以像这样取得这个元素的标签名：

```
let div = document.getElementById("myDiv");
alert(div.tagName); // "DIV"
alert(div.tagName == div.nodeName); // true
```

例子中的元素标签名为`div`，ID为`"myDiv"`。注意，`div.tagName`实际上返回的是`"DIV"`而不是`"div"`。在HTML中，元素标签名始终以全大写表示；在XML（包括XHTML）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在HTML文档还是XML文档中运行，最好将标签名转换为小写形式，以便于比较：

```
if (element.tagName == "div"){ // 不要这样做，可能出错！
  // do something here
}

if (element.tagName.toLowerCase() == "div"){ // 推荐，适用于所有文档
  // 做点什么
}
```

这个例子演示了比较`tagName`属性的情形。第一个是容易出错的写法，因为HTML文档中`tagName`返回大写形式的标签名。第二个先把标签名转换为全部小写后再比较，这是推荐的做法，因为这对HTML和XML都适用。

1. **HTML元素**

   所有HTML元素都通过`HTMLElement`类型表示，包括其直接实例和间接实例。另外，`HTMLElement`直接继承`Element`并增加了一些属性。每个属性都对应下列属性之一，它们是所有HTML元素上都有的标准属性：

   - `id`，元素在文档中的唯一标识符；
   - `title`，包含元素的额外信息，通常以提示条形式展示；
   - `lang`，元素内容的语言代码（很少用）；
   - `dir`，语言的书写方向（`"ltr"`表示从左到右，`"rtl"`表示从右到左，同样很少用）；
   - `className`，相当于`class`属性，用于指定元素的CSS类（因为`class`是ECMAScript关键字，所以不能直接用这个名字）。

   所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。比如有下面的HTML元素：

   ```
   <div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"></div>
   ```

   这个元素中的所有属性都可以使用下列JavaScript代码读取：

   ```
   let div = document.getElementById("myDiv");
   alert(div.id);         // "myDiv"
   alert(div.className);  // "bd"
   alert(div.title);      // "Body text"
   alert(div.lang);       // "en"
   alert(div.dir);        // "ltr"
   ```

   而且，可以使用下列代码修改元素的属性：

   ```
   div.id = "someOtherId";
   div.className = "ft";
   div.title = "Some other text";
   div.lang = "fr";
   div.dir ="rtl";
   ```

   并非所有这些属性的修改都会对页面产生影响。比如，把`id`或`lang`改成其他值对用户是不可见的（假设没有基于这两个属性应用CSS样式），而修改`title`属性则只会在鼠标移到这个元素上时才会反映出来。修改`dir`会导致页面文本立即向左或向右对齐。修改`className`会立即反映应用到新类名的CSS样式（如果定义了不同的样式）。

   如前所述，所有HTML元素都是`HTMLElement`或其子类型的实例。下表列出了所有HTML元素及其对应的类型（斜体表示已经废弃的元素）。

   | 元素       | 类型                       | 元素     | 类型                      |
   | :--------- | :------------------------- | :------- | :------------------------ |
   | A          | `HTMLAnchorElement`        | COL      | `HTMLTableColElement`     |
   | ABBR       | `HTMLElement`              | COLGROUP | `HTMLTableColElement`     |
   | ACRONYM    | `HTMLElement`              | DD       | `HTMLElement`             |
   | ADDRESS    | `HTMLElement`              | DEL      | `HTMLModElement`          |
   | *APPLET*   | `*HTMLAppletElement*`      | DFN      | `HTMLElement`             |
   | AREA       | `HTMLAreaElement`          | *DIR*    | `*HTMLDirectoryElement*`  |
   | B          | `HTMLElement`              | DIV      | `HTMLDivElement`          |
   | BASE       | `HTMLBaseElement`          | DL       | `HTMLDListElement`        |
   | *BASEFONT* | `*HTMLBaseFontElement*`    | DT       | `HTMLElement`             |
   | BDO        | `HTMLElement`              | EM       | `HTMLElement`             |
   | BIG        | `HTMLElement`              | FIELDSET | `HTMLFieldSetElement`     |
   | BLOCKQUOTE | `HTMLQuoteElement`         | *FONT*   | `*HTMLFontElement*`       |
   | BODY       | `HTMLBodyElement`          | FORM     | `HTMLFormElement`         |
   | BR         | `HTMLBRElement`            | FRAME    | `HTMLFrameElement`        |
   | BUTTON     | `HTMLButtonElement`        | FRAMESET | `HTMLFrameSetElement`     |
   | CAPTION    | `HTMLTableCaption Element` | H1       | `HTMLHeadingElement`      |
   | *CENTER*   | `*HTMLElement*`            | H2       | `HTMLHeadingElement`      |
   | CITE       | `HTMLElement`              | H3       | `HTMLHeadingElement`      |
   | CODE       | `HTMLElement`              | H4       | `HTMLHeadingElement`      |
   | H5         | `HTMLHeadingElement`       | PRE      | `HTMLPreElement`          |
   | H6         | `HTMLHeadingElement`       | Q        | `HTMLQuoteElement`        |
   | HEAD       | `HTMLHeadElement`          | *S*      | `*HTMLElement*`           |
   | HR         | `HTMLHRElement`            | SAMP     | `HTMLElement`             |
   | HTML       | `HTMLHtmlElement`          | SCRIPT   | `HTMLScriptElement`       |
   | I          | `HTMLElement`              | SELECT   | `HTMLSelectElement`       |
   | IFRAME     | `HTMLIFrameElement`        | SMALL    | `HTMLElement`             |
   | IMG        | `HTMLImageElement`         | SPAN     | `HTMLElement`             |
   | INPUT      | `HTMLInputElement`         | *STRIKE* | `*HTMLElement*`           |
   | INS        | `HTMLModElement`           | STRONG   | `HTMLElement`             |
   | *ISINDEX*  | `*HTMLIsIndexElement*`     | STYLE    | `HTMLStyleElement`        |
   | KBD        | `HTMLElement`              | SUB      | `HTMLElement`             |
   | LABEL      | `HTMLLabelElement`         | SUP      | `HTMLElement`             |
   | LEGEND     | `HTMLLegendElement`        | TABLE    | `HTMLTableElement`        |
   | LI         | `HTMLLIElement`            | TBODY    | `HTMLTableSectionElement` |
   | LINK       | `HTMLLinkElement`          | TD       | `HTMLTableCellElement`    |
   | MAP        | `HTMLMapElement`           | TEXTAREA | `HTMLTextAreaElement`     |
   | *MENU*     | `*HTMLMenuElement*`        | TFOOT    | `HTMLTableSectionElement` |
   | META       | `HTMLMetaElement`          | TH       | `HTMLTableCellElement`    |
   | NOFRAMES   | `HTMLElement`              | THEAD    | `HTMLTableSectionElement` |
   | NOSCRIPT   | `HTMLElement`              | TITLE    | `HTMLTitleElement`        |
   | OBJECT     | `HTMLObjectElement`        | TR       | `HTMLTableRowElement`     |
   | OL         | `HTMLOListElement`         | TT       | `HTMLElement`             |
   | OPTGROUP   | `HTMLOptGroupElement`      | *U*      | `*HTMLElement*`           |
   | OPTION     | `HTMLOptionElement`        | UL       | `HTMLUListElement`        |
   | P          | `HTMLParagraphElement`     | VAR      | `HTMLElement`             |
   | PARAM      | `HTMLParamElement`         |          |                           |

   这里列出的每种类型都有关联的属性和方法。本书会涉及其中的很多类型。
    

2. **取得属性**

   每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的DOM方法主要有3个：`getAttribute()`、`setAttribute()`和`removeAttribute()`。这些方法主要用于操纵属性，包括在`HTMLElement`类型上定义的属性。下面看一个例子：

   ```
   let div = document.getElementById("myDiv");
   alert(div.getAttribute("id"));     // "myDiv"
   alert(div.getAttribute("class"));  // "bd"
   alert(div.getAttribute("title"));  // "Body text"
   alert(div.getAttribute("lang"));   // "en"
   alert(div.getAttribute("dir"));    // "ltr"
   ```

   注意传给`getAttribute()`的属性名与它们实际的属性名是一样的，因此这里要传`"class"`而非`"className"`（`className`是作为对象属性时才那么拼写的）。如果给定的属性不存在，则`getAttribute()`返回`null`。

   `getAttribute()`方法也能取得不是HTML语言正式属性的自定义属性的值。比如下面的元素：

   ```
   <div id="myDiv" my_special_attribute="hello!"></div>
   ```

   这个元素有一个自定义属性`my_special_attribute`，值为`"hello!"`。可以像其他属性一样使用`getAttribute()`取得这个属性的值：

   ```
   let value = div.getAttribute("my_special_attribute");
   ```

   注意，属性名不区分大小写，因此`"ID"`和`"id"`被认为是同一个属性。另外，根据HTML5规范的要求，自定义属性名应该前缀`data-`以方便验证。

   元素的所有属性也可以通过相应DOM元素对象的属性来取得。当然，这包括`HTMLElement`上定义的直接映射对应属性的5个属性，还有所有公认（非自定义）的属性也会被添加为DOM对象的属性。比如下面的例子：

   ```
   <div id="myDiv" align="left" my_special_attribute="hello"></div>
   ```

   因为`id`和`align`在HTML中是`<div>`元素公认的属性，所以DOM对象上也会有这两个属性。但`my_special_attribute`是自定义属性，因此不会成为DOM对象的属性。

   通过DOM对象访问的属性中有两个返回的值跟使用`getAttribute`()取得的值不一样。首先是`style`属性，这个属性用于为元素设定CSS样式。在使用`getAttribute()`访问style属性时，返回的是CSS字符串。而在通过DOM对象的属性访问时，`style`属性返回的是一个（`CSSStyleDeclaration`）对象。DOM对象的`style`属性用于以编程方式读写元素样式，因此不会直接映射为元素中`style`属性的字符串值。

   第二个属性其实是一类，即事件处理程序（或者事件属性），比如`onclick`。在元素上使用事件属性时（比如`onclick`），属性的值是一段JavaScript代码。如果使用`getAttribute()`访问事件属性，则返回的是字符串形式的源代码。而通过DOM对象的属性访问事件属性时返回的则是一个JavaScript函数（未指定该属性则返回`null`）。这是因为`onclick`及其他事件属性是可以接受函数作为值的。

   考虑到以上差异，开发者在进行DOM编程时通常会放弃使用`getAttribute()`而只使用对象属性。`getAttribute()`主要用于取得自定义属性的值。
    

3. **设置属性**

   与`getAttribute()`配套的方法是`setAttribute()`，这个方法接收两个参数：要设置的属性名和属性的值。如果属性已经存在，则`setAttribute()`会以指定的值替换原来的值；如果属性不存在，则`setAttribute()`会以指定的值创建该属性。下面看一个例子：

   ```
   div.setAttribute("id", "someOtherId");
   div.setAttribute("class", "ft");
   div.setAttribute("title", "Some other text");
   div.setAttribute("lang","fr");
   div.setAttribute("dir", "rtl");
   ```

   `setAttribute()`适用于HTML属性，也适用于自定义属性。另外，使用`setAttribute()`方法设置的属性名会规范为小写形式，因此`"ID"`会变成`"id"`。

   因为元素属性也是DOM对象属性，所以直接给DOM对象的属性赋值也可以设置元素属性的值，如下所示：

   ```
   div.id = "someOtherId";
   div.align = "left";
   ```

   注意，在DOM对象上添加自定义属性，如下面的例子所示，不会自动让它变成元素的属性：

   ```
   div.mycolor = "red";
   alert(div.getAttribute("mycolor")); // null（IE除外）
   ```

   这个例子添加了一个自定义属性`mycolor`并将其值设置为`"red"`。在多数浏览器中，这个属性不会自动变成元素属性。因此调用`getAttribute()`取得`mycolor`的值会返回`null`。

   最后一个方法`removeAttribute()`用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：

   ```
   div.removeAttribute("class");
   ```

   这个方法用得并不多，但在序列化DOM元素时可以通过它控制要包含的属性。
    

4. **`attributes` 属性**

   `Element`类型是唯一使用`attributes`属性的DOM节点类型。`attributes`属性包含一个`NamedNodeMap`实例，是一个类似`NodeList`的“实时”集合。元素的每个属性都表示为一个`Attr`节点，并保存在这个`NamedNodeMap`对象中。`NamedNodeMap`对象包含下列方法：

   - `getNamedItem(*name*)`，返回`nodeName`属性等于`*name*`的节点；
   - `removeNamedItem(*name*)`，删除`nodeName`属性等于`*name*`的节点；
   - `setNamedItem(*node*)`，向列表中添加`*node*`节点，以其`nodeName`为索引；
   - `item(*pos*)`，返回索引位置`*pos*`处的节点。

   `attributes`属性中的每个节点的`nodeName`是对应属性的名字，`nodeValue`是属性的值。比如，要取得元素`id`属性的值，可以使用以下代码：

   ```
   let id = element.attributes.getNamedItem("id").nodeValue;
   ```

   下面是使用中括号访问属性的简写形式：

   ```
   let id = element.attributes["id"].nodeValue;
   ```

   同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其`nodeValue`设置为新值，如下所示：

   ```
   element.attributes["id"].nodeValue = "someOtherId";
   ```

   `removeNamedItem()`方法与元素上的`removeAttribute()`方法类似，也是删除指定名字的属性。下面的例子展示了这两个方法唯一的不同之处，就是`removeNamedItem()`返回表示被删除属性的`Attr`节点：

   ```
   let oldAttr = element.attributes.removeNamedItem("id");
   ```

   `setNamedItem()`方法很少使用，它接收一个属性节点，然后给元素添加一个新属性，如下所示：

   ```
   element.attributes.setNamedItem(newAttr);
   ```

   一般来说，因为使用起来更简便，通常开发者更喜欢使用`getAttribute()`、`removeAttribute()`和`setAttribute()`方法，而不是刚刚介绍的`NamedNodeMap`对象的方法。

   `attributes`属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把DOM结构序列化为XML或HTML字符串。比如，以下代码能够迭代一个元素上的所有属性并以`attribute1= "value1" attribute2="value2"`的形式生成格式化字符串：

   ```
   function outputAttributes(element) {
     let pairs = [];
   
     for (let i = 0, len = element.attributes.length; i < len; ++i) {
       const attribute = element.attributes[i];
       pairs.push(`${attribute.nodeName}="${attribute.nodeValue}"`);
     }
   
     return pairs.join(" ");
   }
   ```

   这个函数使用数组存储每个名/值对，迭代完所有属性后，再将这些名/值对用空格拼接在一起。（这个技术常用于序列化为长字符串。）这个函数中的`for`循环使用`attributes.length`属性迭代每个属性，将每个属性的名字和值输出为字符串。不同浏览器返回的`attributes`中的属性顺序也可能不一样。HTML或XML代码中属性出现的顺序不一定与`attributes`中的顺序一致。
    

5. **创建元素**

   可以使用`document.createElement()`方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在HTML文档中，标签名是不区分大小写的，而XML文档（包括XHTML）是区分大小写的。要创建`<div>`元素，可以使用下面的代码：

   ```
   let div = document.createElement("div");
   ```

   使用`createElement()`方法创建新元素的同时也会将其`ownerDocument`属性设置为`document`。此时，可以再为其添加属性、添加更多子元素。比如：

   ```
   div.id = "myNewDiv";
   div.className = "box";
   ```

   在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用`appendChild()`、`insertBefore()`或`replaceChild()`。比如，以下代码会把刚才创建的元素添加到文档的`<body>`元素中：

   ```
   document.body.appendChild(div);
   ```

   元素被添加到文档树之后，浏览器会立即将其渲染出来。之后再对这个元素所做的任何修改，都会立即在浏览器中反映出来。
    

6. **元素后代**

   元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。`childNodes`属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。比如下面的代码：

   ```
   <ul id="myList">
     <li>Item 1</li>
     <li>Item 2</li>
     <li>Item 3</li>
   </ul>
   ```

   在解析以上代码时，`<ul>`元素会包含7个子元素，其中3个是`<li>`元素，还有4个`Text`节点（表示`<li>`元素周围的空格）。如果把元素之间的空格删掉，变成下面这样，则所有浏览器都会返回同样数量的子节点：

   ```
   <ul id="myList"><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>
   ```

   所有浏览器解析上面的代码后，`<ul>`元素都会包含3个子节点。考虑到这种情况，通常在执行某个操作之后需要先检测一下节点的`nodeType`，如下所示：

   ```
   for (let i = 0, len = element.childNodes.length; i < len; ++i) {
     if (element.childNodes[i].nodeType == 1) {
       // 执行某个操作
     }
   }
   ```

   以上代码会遍历某个元素的子节点，并且只在`nodeType`等于1（即`Element`节点）时执行某个操作。

   要取得某个元素的子节点和其他后代节点，可以使用元素的`getElementsByTagName()`方法。在元素上调用这个方法与在文档上调用是一样的，只不过搜索范围限制在当前元素之内，即只会返回当前元素的后代。对于本节前面`<ul>`的例子，可以像下面这样取得其所有的`<li>`元素：

   ```
   let ul = document.getElementById("myList");
   let items = ul.getElementsByTagName("li");
   ```

   这里例子中的`<ul>`元素只有一级子节点，如果它包含更多层级，则所有层级中的`<li>`元素都会返回。

### 14.1.4　`Text`类型

`Text`节点由`Text`类型表示，包含按字面解释的纯文本，也可能包含转义后的HTML字符，但不含HTML代码。`Text`类型的节点具有以下特征：

- `nodeType`等于3；
- `nodeName`值为`"#text"`；
- `nodeValue`值为节点中包含的文本；
- `parentNode`值为`Element`对象；
- 不支持子节点。

`Text`节点中包含的文本可以通过`nodeValue`属性访问，也可以通过`data`属性访问，这两个属性包含相同的值。修改`nodeValue`或`data`的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法：

- `appendData(*text*)`，向节点末尾添加文本`*text*`；
- `deleteData(*offset, count*)`，从位置`*offset*`开始删除`*count*`个字符；
- `insertData(*offset, text*)`，在位置`*offset*`插入`*text*`；
- `replaceData(*offset, count, text*)`，用`*text*`替换从位置`*offset*`到`*offset* + *count*`的文本；
- `splitText(*offset*)`，在位置`*offset*`将当前文本节点拆分为两个文本节点；
- `substringData(*offset, count*)`，提取从位置`*offset*`到`*offset* + *count*`的文本。

除了这些方法，还可以通过`length`属性获取文本节点中包含的字符数量。这个值等于`nodeValue.length`和`data.length`。

默认情况下，包含文本内容的每个元素最多只能有一个文本节点。例如：

```
<!-- 没有内容，因此没有文本节点 -->
<div></div>

<!-- 有空格，因此有一个文本节点 -->
<div></div>

<!-- 有内容，因此有一个文本节点 -->
<div>Hello World!</div>
```

示例中的第一个`<div>`元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个`<div>`元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的`nodeValue`就是一个空格。第三个`<div>`元素也有一个文本节点的子节点，其`nodeValue`的值为`"Hello World!"`。下列代码可以用来访问这个文本节点：

```
let textNode = div.firstChild; // 或div.childNodes[0]
```

取得文本节点的引用后，可以像这样来修改它：

```
div.firstChild.nodeValue = "Some other message";
```

只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是HTML或XML代码（取决于文档类型）会被转换成实体编码，即小于号、大于号或引号会被转义，如下所示：

```
// 输出为"Some &lt;strong&gt;other&lt;/strong&gt; message"
div.firstChild.nodeValue = "Some <strong>other</strong> message";
```

这实际上是在将HTML字符串插入DOM文档前进行编码的有效方式。

1. **创建文本节点**

   `document.createTextNode()`可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。跟设置已有文本节点的值一样，这些要插入的文本也会应用HTML或XML编码，如下面的例子所示：

   ```
   let textNode = document.createTextNode("<strong>Hello</strong> world!");
   ```

   创建新文本节点后，其`ownerDocument`属性会被设置为`document`。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。以下代码创建了一个`<div>`元素并给它添加了一段文本消息：

   ```
   let element = document.createElement("div");
   element.className = "message";
   
   let textNode = document.createTextNode("Hello world!");
   element.appendChild(textNode);
   
   document.body.appendChild(element);
   ```

   这个例子首先创建了一个`<div>`元素并给它添加了值为`"message"`的`class`属性，然后又创建了一个文本节点并添加到该元素。最后一步是把这个元素添加到文档的主体上，这样元素及其包含的文本会出现在浏览器中。

   一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点，如下面的例子所示：

   ```
   let element = document.createElement("div");
   element.className = "message";
   
   let textNode = document.createTextNode("Hello world!");
   element.appendChild(textNode);
   
   let anotherTextNode = document.createTextNode("Yippee!");
   element.appendChild(anotherTextNode);
   
   document.body.appendChild(element);
   ```

   在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。
    

2. **规范化文本节点**

   DOM文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样，DOM文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫`normalize()`，是在`Node`类型中定义的（因此所有类型的节点上都有这个方法）。在包含两个或多个相邻文本节点的父节点上调用`normalize()`时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的`nodeValue`就等于之前所有同胞节点`nodeValue`拼接在一起得到的字符串。来看下面的例子：

   ```
   let element = document.createElement("div");
   element.className = "message";
   
   let textNode = document.createTextNode("Hello world!");
   element.appendChild(textNode);
   
   let anotherTextNode = document.createTextNode("Yippee!");
   element.appendChild(anotherTextNode);
   
   document.body.appendChild(element);
   
   alert(element.childNodes.length);    // 2
   
   element.normalize();
   alert(element.childNodes.length);    // 1
   alert(element.firstChild.nodeValue); // "Hello world!Yippee!"
   ```

   浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在DOM脚本生成的文档树中。
    

3. **拆分文本节点**

   `Text`类型定义了一个与`normalize()`相反的方法——`splitText()`。这个方法可以在指定的偏移位置拆分`nodeValue`，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的`parentNode`。来看下面的例子：

   ```
   let element = document.createElement("div");
   element.className = "message";
   
   let textNode = document.createTextNode("Hello world!");
   element.appendChild(textNode);
   
   document.body.appendChild(element);
   
   let newNode = element.firstChild.splitText(5);
   alert(element.firstChild.nodeValue);  // "Hello"
   alert(newNode.nodeValue);             // " world!"
   alert(element.childNodes.length);     // 2
   ```

   在这个例子中，包含`"Hello world!"`的文本节点被从位置`5`拆分成两个文本节点。位置`5`对应`"Hello"`和`"world!"`之间的空格，因此原始文本节点包含字符串`"Hello"`，而新文本节点包含文本`" world!"`（包含空格）。

   拆分文本节点最常用于从文本节点中提取数据的DOM解析技术。

### 14.1.5　`Comment`类型

DOM中的注释通过`Comment`类型表示。`Comment`类型的节点具有以下特征：

- `nodeType`等于8；
- `nodeName`值为`"#comment"`；
- `nodeValue`值为注释的内容；
- `parentNode`值为`Document`或`Element`对象；
- 不支持子节点。

`Comment`类型与`Text`类型继承同一个基类（`CharacterData`），因此拥有除`splitText()`之外`Text`节点所有的字符串操作方法。与`Text`类型相似，注释的实际内容可以通过`nodeValue`或`data`属性获得。

注释节点可以作为父节点的子节点来访问。比如下面的HTML代码：

```
<div id="myDiv"><!-- A comment --></div>
```

这里的注释是`<div>`元素的子节点，这意味着可以像下面这样访问它：

```
let div = document.getElementById("myDiv");
let comment = div.firstChild;
alert(comment.data); // "A comment"
```

可以使用`document.createComment()`方法创建注释节点，参数为注释文本，如下所示：

```
let comment = document.createComment("A comment");
```

显然，注释节点很少通过JavaScrpit创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的`</html>`标签之后的注释。如果要访问注释节点，则必须确定它们是`<html>`元素的后代。

### 14.1.6　`CDATASection`类型

`CDATASection`类型表示XML中特有的CDATA区块。`CDATASection`类型继承`Text`类型，因此拥有包括`splitText()`在内的所有字符串操作方法。`CDATASection`类型的节点具有以下特征：

- `nodeType`等于4；
- `nodeName`值为`"#cdata-section"`；
- `nodeValue`值为CDATA区块的内容；
- `parentNode`值为`Document`或`Element`对象；
- 不支持子节点。

CDATA区块只在XML文档中有效，因此某些浏览器比较陈旧的版本会错误地将CDATA区块解析为`Comment`或`Element`。比如下面这行代码：

```
<div id="myDiv"><![CDATA[This is some content.]]></div>
```

这里`<div>`的第一个子节点应该是`CDATASection`节点。但主流的四大浏览器没有一个将其识别为`CDATASection`。即使在有效的XHTML文档中，这些浏览器也不能恰当地支持嵌入的CDATA区块。

在真正的XML文档中，可以使用`document.createCDataSection()`并传入节点内容来创建CDATA区块。

### 14.1.7　`DocumentType`类型

`DocumentType`类型的节点包含文档的文档类型（`doctype`）信息，具有以下特征：

- `nodeType`等于10；
- `nodeName`值为文档类型的名称；
- `nodeValue`值为`null`；
- `parentNode`值为`Document`对象；
- 不支持子节点。

`DocumentType`对象在DOM Level 1中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，`DocumentType`对象保存在`document.doctype`属性中。DOM Level 1规定了`DocumentType`对象的3个属性：`name`、`entities`和`notations`。其中，`name`是文档类型的名称，`entities`是这个文档类型描述的实体的`NamedNodeMap`，而`notations`是这个文档类型描述的表示法的`NamedNodeMap`。因为浏览器中的文档通常是HTML或XHTML文档类型，所以`entities`和`notations`列表为空。（这个对象只包含行内声明的文档类型。）无论如何，只有`name`属性是有用的。这个属性包含文档类型的名称，即紧跟在`<!DOCTYPE`后面的那串文本。比如下面的HTML 4.01严格文档类型：

```
<!DOCTYPE HTML PUBLIC "-// W3C// DTD HTML 4.01// EN"
  "http:// www.w3.org/TR/html4/strict.dtd">
```

对于这个文档类型，`name`属性的值是`"HTML"`：

```
alert(document.doctype.name); // "HTML"
```

### 14.1.8　`DocumentFragment`类型

在所有节点类型中，`DocumentFragment`类型是唯一一个在标记中没有对应表示的类型。DOM将文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。`DocumentFragment`节点具有以下特征：

- `nodeType`等于11；
- `nodeName`值为`"#document-fragment"`；
- `nodeValue`值为`null`；
- `parentNode`值为`null`；
- 子节点可以是`Element`、`ProcessingInstruction`、`Comment`、`Text`、`CDATASection`或`EntityReference`。

不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。可以使用`document.createDocumentFragment()`方法像下面这样创建文档片段：

```
let fragment = document.createDocumentFragment();
```

文档片段从`Node`类型继承了所有文档类型具备的可以执行DOM操作的方法。如果文档中的一个节点被添加到一个文档片段，则该节点会从文档树中移除，不会再被浏览器渲染。添加到文档片段的新节点同样不属于文档树，不会被浏览器渲染。可以通过`appendChild()`或`insertBefore()`方法将文档片段的内容添加到文档。在把文档片段作为参数传给这些方法时，这个文档片段的所有子节点会被添加到文档中相应的位置。文档片段本身永远不会被添加到文档树。以下面的HTML为例：

```
<ul id="myList"></ul>
```

假设想给这个`<ul>`元素添加3个列表项。如果分3次给这个元素添加列表项，浏览器就要重新渲染3次页面，以反映新添加的内容。为避免多次渲染，下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了`<ul>`元素：

```
let fragment = document.createDocumentFragment();
let ul = document.getElementById("myList");

for (let i = 0; i < 3; ++i) {
  let li = document.createElement("li");
  li.appendChild(document.createTextNode(`Item ${i + 1}`));
  fragment.appendChild(li);
}

ul.appendChild(fragment);
```

这个例子先创建了一个文档片段，然后取得了`<ul>`元素的引用。接着通过`for`循环创建了3个列表项，每一项都包含表明自己身份的文本。为此先创建`<li>`元素，再创建文本节点并添加到该元素。然后通过`appendChild()`把`<li>`元素添加到文档片段。循环结束后，通过把文档片段传给`appendChild()`将所有列表项添加到了`<ul>`元素。此时，文档片段的子节点全部被转移到了`<ul>`元素。

### 14.1.9　`Attr`类型

元素数据在DOM中通过`Attr`类型表示。`Attr`类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素`attributes`属性中的节点。`Attr`节点具有以下特征：

- `nodeType`等于2；
- `nodeName`值为属性名；
- `nodeValue`值为属性值；
- `parentNode`值为`null`；
- 在HTML中不支持子节点；
- 在XML中子节点可以是`Text`或`EntityReference`。

属性节点尽管是节点，却不被认为是DOM文档树的一部分。`Attr`节点很少直接被引用，通常开发者更喜欢使用`getAttribute()`、`removeAttribute()`和`setAttribute()`方法操作属性。

`Attr`对象上有3个属性：`name`、`value`和`specified`。其中，`name`包含属性名（与`nodeName`一样），`value`包含属性值（与`nodeValue`一样），而`specified`是一个布尔值，表示属性使用的是默认值还是被指定的值。

可以使用`document.createAttribute()`方法创建新的`Attr`节点，参数为属性名。比如，要给元素添加`align`属性，可以使用下列代码：

```
let attr = document.createAttribute("align");
attr.value = "left";
element.setAttributeNode(attr);

alert(element.attributes["align"].value);       // "left"
alert(element.getAttributeNode("align").value); // "left"
alert(element.getAttribute("align"));           // "left"
```

在这个例子中，首先创建了一个新属性。调用`createAttribute()`并传入`"align"`为新属性设置了`name`属性，因此就不用再设置了。随后，`value`属性被赋值为`"left"`。为把这个新属性添加到元素上，可以使用元素的`setAttributeNode()`方法。添加这个属性后，可以通过不同方式访问它，包括`attributes`属性、`getAttributeNode()`和`getAttribute()`方法。其中，`attributes`属性和`getAttributeNode()`方法都返回属性对应的`Attr`节点，而`getAttribute()`方法只返回属性的值。

> **注意**　将属性作为节点来访问多数情况下并无必要。推荐使用`getAttribute()`、`removeAttribute()`和`setAttribute()`方法操作属性，而不是直接操作属性节点。

## 14.2　DOM编程

很多时候，操作DOM是很直观的。通过HTML代码能实现的，也一样能通过JavaScript实现。但有时候，DOM也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致DOM的某些方面会复杂一些。

### 14.2.1　动态脚本

<script>元素用于向网页中插入JavaScript代码，可以是src属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过DOM包含的脚本。与对应的HTML元素一样，有两种方式通过<script>动态为网页添加脚本：引入外部文件和直接插入源代码。

动态加载外部文件很容易实现，比如下面的`<script>`元素：

```
<script src="foo.js"></script>
```

可以像这样通过DOM编程创建这个节点：

```
let script = document.createElement("script");
script.src = "foo.js";
document.body.appendChild(script);
```

这里的DOM代码实际上完全照搬了它要表示的HTML代码。注意，在上面最后一行把`<script>`元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到`<head>`元素，同样可以实现动态脚本加载。这个过程可以抽象为一个函数，比如：

```
function loadScript(url) {
  let script = document.createElement("script");
  script.src = url;
  document.body.appendChild(script);
}
```

然后，就可以像下面这样加载外部JavaScript文件了：

```
loadScript("client.js");
```

加载之后，这个脚本就可以对页面执行操作了。这里有个问题：怎么能知道脚本什么时候加载完？这个问题并没有标准答案。第17章会讨论一些与加载相关的事件，具体情况取决于使用的浏览器。

另一个动态插入JavaScript的方式是嵌入源代码，如下面的例子所示：

```
<script>
  function sayHi() {
    alert("hi");
  }
</script>
```

使用DOM，可以实现以下逻辑：

```
let script = document.createElement("script");
script.appendChild(document.createTextNode("function sayHi(){alert('hi');}"));
document.body.appendChild(script);
```

以上代码可以在`Firefox`、`Safari`、`Chrome`和`Opera`中运行。不过在旧版本的IE中可能会导致问题。这是因为IE对`<script>`元素做了特殊处理，不允许常规DOM访问其子节点。但`<script>`元素上有一个`text`属性，可以用来添加JavaScript代码，如下所示：

```
var script = document.createElement("script");
script.text = "function sayHi(){alert('hi');}";
document.body.appendChild(script);
```

这样修改后，上面的代码可以在IE、Firefox、Opera和Safari 3及更高版本中运行。Safari 3之前的版本不能正确支持这个`text`属性，但这些版本却支持文本节点赋值。对于早期的Safari版本，需要使用以下代码：

```
var script = document.createElement("script");
var code = "function sayHi(){alert('hi');}";
try {
  script.appendChild(document.createTextNode("code"));
} catch (ex){
  script.text = "code";
}
document.body.appendChild(script);
```

这里先尝试使用标准的DOM文本节点插入方式，因为除IE之外的浏览器都支持这种方式。IE此时会抛出错误，那么可以在捕获错误之后再使用`text`属性来插入JavaScript代码。于是，我们就可以抽象出一个跨浏览器的函数：

```
function loadScriptString(code){
  var script = document.createElement("script");
  script.type = "text/javascript";
  try {
    script.appendChild(document.createTextNode(code));
  } catch (ex){
    script.text = code;
  }
  document.body.appendChild(script);
}
```

这个函数可以这样调用：

```
loadScriptString("function sayHi(){alert('hi');}");
```

以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生效。基本上，这就相当于在全局作用域中把源代码传给`eval()`方法。

注意，通过`innerHTML`属性创建的`<script>`元素永远不会执行。浏览器会尽责地创建`<script>`元素，以及其中的脚本文本，但解析器会给这个`<script>`元素打上永不执行的标签。只要是使用`innerHTML`创建的`<script>`元素，以后也没有办法强制其执行。

### 14.2.2　动态样式

CSS样式在HTML页面中可以通过两个元素加载。`<link>`元素用于包含CSS外部文件，而`<style>`元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。

来看下面这个典型的`<link>`元素：

```
<link rel="stylesheet" type="text/css" href="styles.css">
```

这个元素很容易使用DOM编程创建出来：

```
let link = document.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
link.href = "styles.css";
let head = document.getElementsByTagName("head")[0];
head.appendChild(link);
```

以上代码在所有主流浏览器中都能正常运行。注意应该把`<link>`元素添加到`<head>`元素而不是`<body>`元素，这样才能保证所有浏览器都能正常运行。这个过程可以抽象为以下通用函数：

```
function loadStyles(url){
  let link = document.createElement("link");
  link.rel = "stylesheet";
  link.type = "text/css";
  link.href = url;
  let head = document.getElementsByTagName("head")[0];
  head.appendChild(link);
}
```

然后就可以这样调用这个`loadStyles()`函数了：

```
loadStyles("styles.css");
```

通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的JavaScript代码并没有先后顺序。一般来说，也没有必要知道样式什么时候加载完成。

另一种定义样式的方式是使用`<script>`元素包含嵌入的CSS规则，例如：

```
<style type="text/css">
body {
  background-color: red;
}
</style>
```

逻辑上，下列DOM代码会有同样的效果：

```
let style = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode("body{background-color:red}"));
let head = document.getElementsByTagName("head")[0];
head.appendChild(style);
```

以上代码在Firefox、Safari、Chrome和Opera中都可以运行，但IE除外。IE对`<style>`节点会施加限制，不允许访问其子节点，这一点与它对`<script>`元素施加的限制一样。事实上，IE在执行到给`<style>`添加子节点的代码时，会抛出与给`<script>`添加子节点时同样的错误。对于IE，解决方案是访问元素的`styleSheet`属性，这个属性又有一个`cssText`属性，然后给这个属性添加CSS代码：

```
let style = document.createElement("style");
style.type = "text/css";
try{
  style.appendChild(document.createTextNode("body{background-color:red}"));
} catch (ex){
  style.styleSheet.cssText = "body{background-color:red}";
}
let head = document.getElementsByTagName("head")[0];
head.appendChild(style);
```

与动态添加脚本源代码类似，这里也使用了`try...catch`语句捕获IE抛出的错误，然后再以IE特有的方式来设置样式。这是最终的通用函数：

```
function loadStyleString(css){
  let style = document.createElement("style");
  style.type = "text/css";
  try{
    style.appendChild(document.createTextNode(css));
  } catch (ex){
    style.styleSheet.cssText = css;
  }
  let head = document.getElementsByTagName("head")[0];
    head.appendChild(style);
}
```

可以这样调用这个函数：

```
loadStyleString("body{background-color:red}");
```

这样添加的样式会立即生效，因此所有变化会立即反映出来。

> **注意**　对于IE，要小心使用`styleSheet.cssText`。如果重用同一个`<style>`元素并设置该属性超过一次，则可能导致浏览器崩溃。同样，将`cssText`设置为空字符串也可能导致浏览器崩溃。

### 14.2.3　操作表格

表格是HTML中最复杂的结构之一。通过DOM编程创建`<table>`元素，通常要涉及大量标签，包括表行、表元、表题，等等。因此，通过DOM编程创建和修改表格时可能要写很多代码。假设要通过DOM来创建以下HTML表格：

```
<table border="1" width="100%">
  <tbody>
    <tr>
      <td>Cell 1,1</td>
      <td>Cell 2,1</td>
    </tr>
    <tr>
      <td>Cell 1,2</td>
      <td>Cell 2,2</td>
    </tr>
  </tbody>
</table>
```

下面就是以DOM编程方式重建这个表格的代码：

```
// 创建表格
let table = document.createElement("table");
table.border = 1;
table.width = "100%";

// 创建表体
let tbody = document.createElement("tbody");
table.appendChild(tbody);

// 创建第一行
let row1 = document.createElement("tr");
tbody.appendChild(row1);
let cell1_1 = document.createElement("td");
cell1_1.appendChild(document.createTextNode("Cell 1,1"));
row1.appendChild(cell1_1);
let cell2_1 = document.createElement("td");
cell2_1.appendChild(document.createTextNode("Cell 2,1"));
row1.appendChild(cell2_1);

// 创建第二行
let row2 = document.createElement("tr");
tbody.appendChild(row2);
let cell1_2 = document.createElement("td");
cell1_2.appendChild(document.createTextNode("Cell 1,2"));
row2.appendChild(cell1_2);
let cell2_2= document.createElement("td");
cell2_2.appendChild(document.createTextNode("Cell 2,2"));
row2.appendChild(cell2_2);

// 把表格添加到文档主体
document.body.appendChild(table);
```

以上代码相当烦琐，也不好理解。为了方便创建表格，HTML DOM给`<table>`、`<tbody>`和`<tr>`元素添加了一些属性和方法。

<table>元素添加了以下属性和方法：

- `caption`，指向`<caption>`元素的指针（如果存在）；
- `tBodies`，包含`<tbody>`元素的`HTMLCollection`；
- `tFoot`，指向`<tfoot>`元素（如果存在）；
- `tHead`，指向`<thead>`元素（如果存在）；
- `rows`，包含表示所有行的`HTMLCollection`；
- `createTHead()`，创建`<thead>`元素，放到表格中，返回引用；
- `createTFoot()`，创建`<tfoot>`元素，放到表格中，返回引用；
- `createCaption()`，创建`<caption>`元素，放到表格中，返回引用；
- `deleteTHead()`，删除`<thead>`元素；
- `deleteTFoot()`，删除`<tfoot>`元素；
- `deleteCaption()`，删除`<caption>`元素；
- `deleteRow(*pos*)`，删除给定位置的行；
- `insertRow(*pos*)`，在行集合中给定位置插入一行。

`<tbody>`元素添加了以下属性和方法：

- `rows`，包含`<tbody>`元素中所有行的`HTMLCollection`；
- `deleteRow(*pos*)`，删除给定位置的行；
- `insertRow(*pos*)`，在行集合中给定位置插入一行，返回该行的引用。

`<tr>`元素添加了以下属性和方法：

- `cells`，包含`<tr>`元素所有表元的`HTMLCollection`；
- `deleteCell(*pos*)`，删除给定位置的表元；
- `insertCell(*pos*)`，在表元集合给定位置插入一个表元，返回该表元的引用。

这些属性和方法极大地减少了创建表格所需的代码量。例如，使用这些方法重写前面的代码之后是这样的（加粗代码表示更新的部分）：

```
// 创建表格
let table = document.createElement("table");
table.border = 1;
table.width = "100%";

// 创建表体
let tbody = document.createElement("tbody");
table.appendChild(tbody);

// 创建第一行
tbody.insertRow(0);
tbody.rows[0].insertCell(0);
tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));
tbody.rows[0].insertCell(1);
tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));

// 创建第二行
tbody.insertRow(1);
tbody.rows[1].insertCell(0);
tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));
tbody.rows[1].insertCell(1);
tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));

// 把表格添加到文档主体
document.body.appendChild(table);
```

这里创建`<table>`和`<tbody>`元素的代码没有变。变化的是创建两行的部分，这次使用了HTML DOM表格的属性和方法。创建第一行时，在`<tbody>`元素上调用了`insertRow()`方法。传入参数`0`，表示把这一行放在什么位置。然后，使用`tbody.rows[0]`来引用这一行，因为这一行刚刚创建并被添加到了`<tbody>`的位置`0`。

创建表元的方式也与之类似。在`<tr>`元素上调用`insertCell()`方法，传入参数`0`，表示把这个表元放在什么位置上。然后，使用`tbody.rows[0].cells[0]`来引用这个表元，因为这个表元刚刚创建并被添加到了`<tr>`的位置`0`。

虽然以上两种代码在技术上都是正确的，但使用这些属性和方法创建表格让代码变得更有逻辑性，也更容易理解。

### 14.2.4　使用`NodeList`

理解`NodeList`对象和相关的`NamedNodeMap`、`HTMLCollection`，是理解DOM编程的关键。这3个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，`NodeList`就是基于DOM文档的实时查询。例如，下面的代码会导致无穷循环：

```
let divs = document.getElementsByTagName("div");

for (let i = 0; i < divs.length; ++i){
  let div = document.createElement("div");
  document.body.appendChild(div);
}
```

第一行取得了包含文档中所有`<div>`元素的`HTMLCollection`。因为这个集合是“实时的”，所以任何时候只要向页面中添加一个新`<div>`元素，再查询这个集合就会多一项。因为浏览器不希望保存每次创建的集合，所以就会在每次访问时更新集合。这样就会出现前面使用循环的例子中所演示的问题。每次循环开始，都会求值`i < divs.length`。这意味着要执行获取所有`<div>`元素的查询。因为循环体中会创建并向文档添加一个新`<div>`元素，所以每次循环`divs.length`的值也会递增。因为两个值都会递增，所以`i`将永远不会等于`divs.length`。

使用ES6迭代器并不会解决这个问题，因为迭代的是一个永远增长的实时集合。以下代码仍然会导致无穷循环：

```
for (let div of document.getElementsByTagName("div")){
  let newDiv = document.createElement("div");
  document.body.appendChild(newDiv);
}
```

任何时候要迭代`NodeList`，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较，如下所示：

```
let divs = document.getElementsByTagName("div");

for (let i = 0, len = divs.length; i < len; ++i) {
  let div = document.createElement("div");
  document.body.appendChild(div);
}
```

在这个例子中，又初始化了一个保存集合长度的变量`len`。因为`len`保存着循环开始时集合的长度，而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。本章还会使用这种技术来演示迭代`NodeList`对象的首选方式。

另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合：

```
let divs = document.getElementsByTagName("div");

for (let i = divs.length - 1; i >= 0; --i) {
  let div = document.createElement("div");
  document.body.appendChild(div);
}
```

一般来说，最好限制操作`NodeList`的次数。因为每次查询都会搜索整个文档，所以最好把查询到的`NodeList`缓存起来。

## 14.3　`MutationObserver`接口

不久前添加到DOM规范中的`MutationObserver`接口，可以在DOM被修改时异步执行回调。使用`MutationObserver`可以观察整个文档、DOM树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。

> **注意**　新引进`MutationObserver`接口是为了取代废弃的`MutationEvent`。

### 14.3.1　基本用法

`MutationObserver`的实例要通过调用`MutationObserver`构造函数并传入一个回调函数来创建：

```
let observer = new MutationObserver(() => console.log('DOM was mutated!'));
```

1. **`observe()`方法**

   新创建的`MutationObserver`实例不会关联DOM的任何部分。要把这个`observer`与DOM关联起来，需要使用`observe()`方法。这个方法接收两个必需的参数：要观察其变化的DOM节点，以及一个`MutationObserverInit`对象。

   `MutationObserverInit`对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。例如，下面的代码会创建一个观察者（`observer`）并配置它观察`<body>`元素上的属性变化：

   ```
   let observer = new MutationObserver(() => console.log('<body> attributes changed'));
   
   observer.observe(document.body, { attributes: true });
   ```

   执行以上代码后，`<body>`元素上任何属性发生变化都会被这个`MutationObserver`实例发现，然后就会异步执行注册的回调函数。`<body>`元素后代的修改或其他非属性修改都不会触发回调进入任务队列。可以通过以下代码来验证：

   ```
   let observer = new MutationObserver(() => console.log('<body> attributes changed'));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   console.log('Changed body class');
   
   // Changed body class
   // <body> attributes changed
   ```

   注意，回调中的`console.log()`是后执行的。这表明回调并非与实际的DOM变化同步执行。
    

2. **回调与`MutationRecord`**

   每个回调都会收到一个`MutationRecord`实例的数组。`MutationRecord`实例包含的信息包括发生了什么变化，以及DOM的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的`MutationRecord`实例的数组。

   下面展示了反映一个属性变化的`MutationRecord`实例的数组：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.setAttribute('foo', 'bar');
   // [
   //   {
   //     addedNodes: NodeList [],
   //     attributeName: "foo",
   //     attributeNamespace: null,
   //     nextSibling: null,
   //     oldValue: null,
   //     previousSibling: null
   //     removedNodes: NodeList [],
   //     target: body
   //     type: "attributes"
   //   }
   // ]
   ```

   下面是一次涉及命名空间的类似变化：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.setAttributeNS('baz', 'foo', 'bar');
   
   // [
   //   {
   //     addedNodes: NodeList [],
   //     attributeName: "foo",
   //     attributeNamespace: "baz",
   //     nextSibling: null,
   //     oldValue: null,
   //     previousSibling: null
   //     removedNodes: NodeList [],
   //     target: body
   //     type: "attributes"
   //   }
   // ]
   ```

   连续修改会生成多个`MutationRecord`实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   document.body.className = 'bar';
   document.body.className = 'baz';
   
   // [MutationRecord, MutationRecord, MutationRecord]
   ```

   下表列出了`MutationRecord`实例的属性。

   | 属性                 | 说明                                                         |
   | :------------------- | :----------------------------------------------------------- |
   | `target`             | 被修改影响的目标节点                                         |
   | `type`               | 字符串，表示变化的类型：`"attributes"`、`"characterData"`或`"childList"` |
   | `oldValue`           | 如果在`MutationObserverInit`对象中启用（`attributeOldValue`或`characterData OldValue`为`true`），`"attributes"`或`"characterData"`的变化事件会设置这个属性为被替代的值 `"childList"`类型的变化始终将这个属性设置为`null` |
   | `attributeName`      | 对于`"attributes"`类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为`null` |
   | `attributeNamespace` | 对于使用了命名空间的`"attributes"`类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为`null` |
   | `addedNodes`         | 对于`"childList"`类型的变化，返回包含变化中添加节点的`NodeList` 默认为空`NodeList` |
   | `removedNodes`       | 对于`"childList"`类型的变化，返回包含变化中删除节点的`NodeList` 默认为空`NodeList` |
   | `previousSibling`    | 对于`"childList"`类型的变化，返回变化节点的前一个同胞`Node` 默认为`null` |
   | `nextSibling`        | 对于`"childList"`类型的变化，返回变化节点的后一个同胞`Node` 默认为`null` |

   传给回调函数的第二个参数是观察变化的`MutationObserver`的实例，演示如下：

   ```
   let observer = new MutationObserver(
       (mutationRecords, mutationObserver) => console.log(mutationRecords,
   mutationObserver));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   
   // [MutationRecord], MutationObserver
   ```

    

3. **`disconnect()`方法**

   默认情况下，只要被观察的元素不被垃圾回收，`MutationObserver`的回调就会响应DOM变化事件，从而被执行。要提前终止执行回调，可以调用`disconnect()`方法。下面的例子演示了同步调用`disconnect()`之后，不仅会停止此后变化事件的回调，也会抛弃已经加入任务队列要异步执行的回调：

   ```
   let observer = new MutationObserver(() => console.log('<body> attributes changed'));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   
   observer.disconnect();
   
   document.body.className = 'bar';
   
   //（没有日志输出）
   ```

   要想让已经加入任务队列的回调执行，可以使用`setTimeout()`让已经入列的回调执行完毕再调用`disconnect()`：

   ```
   let observer = new MutationObserver(() => console.log('<body> attributes changed'));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   
   setTimeout(() => {
     observer.disconnect();
     document.body.className = 'bar';
   }, 0);
   
   // <body> attributes changed
   ```

    

4. **复用`MutationObserver`**

   多次调用`observe()`方法，可以复用一个`MutationObserver`对象观察多个不同的目标节点。此时，`MutationRecord`的`target`属性可以标识发生变化事件的目标节点。下面的示例演示了这个过程：

   ```
   let observer = new MutationObserver(
                  (mutationRecords) => console.log(mutationRecords.map((x) =>
   x.target)));
   
   // 向页面主体添加两个子节点
   let childA = document.createElement('div'),
       childB = document.createElement('span');
   document.body.appendChild(childA);
   document.body.appendChild(childB);
   
   // 观察两个子节点
   observer.observe(childA, { attributes: true });
   observer.observe(childB, { attributes: true });
   
   // 修改两个子节点的属性
   childA.setAttribute('foo', 'bar');
   childB.setAttribute('foo', 'bar');
   
   // [<div>, <span>]
   ```

   `disconnect()`方法是一个“一刀切”的方案，调用它会停止观察所有目标：

   ```
   let observer = new MutationObserver(
                  (mutationRecords) => console.log(mutationRecords.map((x) =>
   x.target)));
   
   // 向页面主体添加两个子节点
   let childA = document.createElement('div'),
       childB = document.createElement('span');
   document.body.appendChild(childA);
   document.body.appendChild(childB);
   
   // 观察两个子节点
   observer.observe(childA, { attributes: true });
   observer.observe(childB, { attributes: true });
   
   observer.disconnect();
   
   // 修改两个子节点的属性
   childA.setAttribute('foo', 'bar');
   childB.setAttribute('foo', 'bar');
   
   // （没有日志输出）
   ```

    

5. **重用`MutationObserver`**

   调用`disconnect()`并不会结束`MutationObserver`的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。下面的示例在两个连续的异步块中先断开然后又恢复了观察者与`<body>`元素的关联：

   ```
   let observer = new MutationObserver(() => console.log('<body> attributes
   changed'));
   
   observer.observe(document.body, { attributes: true });
   
   // 这行代码会触发变化事件
   document.body.setAttribute('foo', 'bar');
   
   setTimeout(() => {
     observer.disconnect();
   
     // 这行代码不会触发变化事件
     document.body.setAttribute('bar', 'baz');
   }, 0);
   　
   　
   setTimeout(() => {
     // Reattach
     observer.observe(document.body, { attributes: true });
   
     // 这行代码会触发变化事件
     document.body.setAttribute('baz', 'qux');
   }, 0);
   
   // <body> attributes changed
   // <body> attributes changed
   ```

### 14.3.2　`MutationObserverInit`与观察范围

`MutationObserverInit`对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。

下表列出了`MutationObserverInit`对象的属性。

| 属性                    | 说明                                                         |
| :---------------------- | :----------------------------------------------------------- |
| `subtree`               | 布尔值，表示除了目标节点，是否观察目标节点的子树（后代） 如果是`false`，则只观察目标节点的变化；如果是`true`，则观察目标节点及其整个子树 默认为`false` |
| `attributes`            | 布尔值，表示是否观察目标节点的属性变化 默认为`false`         |
| `attributeFilter`       | 字符串数组，表示要观察哪些属性的变化 把这个值设置为`true`也会将`attributes`的值转换为`true` 默认为观察所有属性 |
| `attributeOldValue`     | 布尔值，表示`MutationRecord`是否记录变化之前的属性值 把这个值设置为`true`也会将`attributes`的值转换为`true` 默认为`false` |
| `characterData`         | 布尔值，表示修改字符数据是否触发变化事件 默认为`false`       |
| `characterDataOldValue` | 布尔值，表示`MutationRecord`是否记录变化之前的字符数据 把这个值设置为`true`也会将`characterData`的值转换为`true` 默认为`false` |
| `childList`             | 布尔值，表示修改目标节点的子节点是否触发变化事件 默认为`false` |

> **注意**　在调用`observe()`时，`MutationObserverInit`对象中的`attribute`、`characterData`和`childList`属性必须至少有一项为`true`（无论是直接设置这几个属性，还是通过设置`attributeOldValue`等属性间接导致它们的值转换为`true`）。否则会抛出错误，因为没有任何变化事件可能触发回调。

1. **观察属性**

   `MutationObserver`可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在`MutationObserverInit`对象中将`attributes`属性设置为`true`，如下所示：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributes: true });
   
   // 添加属性
   document.body.setAttribute('foo', 'bar');
   
   // 修改属性
   document.body.setAttribute('foo', 'baz');
   
   // 移除属性
   document.body.removeAttribute('foo');
   
   // 以上变化都被记录下来了
   // [MutationRecord, MutationRecord, MutationRecord]
   ```

   把`attributes`设置为`true`的默认行为是观察所有属性，但不会在`MutationRecord`对象中记录原来的属性值。如果想观察某个或某几个属性，可以使用`attributeFilter`属性来设置白名单，即一个属性名字符串数组：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributeFilter: ['foo'] });
   
   // 添加白名单属性
   document.body.setAttribute('foo', 'bar');
   
   // 添加被排除的属性
   document.body.setAttribute('baz', 'qux');
   
   // 只有foo属性的变化被记录了
   // [MutationRecord]
   ```

   如果想在变化记录中保存属性原来的值，可以将`attributeOldValue`属性设置为`true`：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords.map((x) => x.oldValue)));
   
   observer.observe(document.body, { attributeOldValue: true });
   
   document.body.setAttribute('foo', 'bar');
   document.body.setAttribute('foo', 'baz');
   document.body.setAttribute('foo', 'qux');
   
   // 每次变化都保留了上一次的值
   // [null, 'bar', 'baz']
   ```

    

2. **观察字符数据**

   `MutationObserver`可以观察文本节点（如`Text`、`Comment`或`ProcessingInstruction`节点）中字符的添加、删除和修改。要为字符数据注册回调，需要在`MutationObserverInit`对象中将`characterData`属性设置为`true`，如下所示：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   // 创建要观察的文本节点
   document.body.innerText = 'foo';
   
   observer.observe(document.body.firstChild, { characterData: true });
   
   // 赋值为相同的字符串
   document.body.innerText = 'foo';
   
   // 赋值为新字符串
   document.body.innerText = 'bar';
   
   // 通过节点设置函数赋值
   document.body.firstChild.textContent = 'baz';
   
   // 以上变化都被记录下来了
   // [MutationRecord, MutationRecord, MutationRecord]
   ```

   将`characterData`属性设置为`true`的默认行为不会在`MutationRecord`对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将`characterDataOldValue`属性设置为`true`：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords.map((x) => x.oldValue)));
   document.body.innerText = 'foo';
   
   observer.observe(document.body.firstChild, { characterDataOldValue: true });
   
   document.body.innerText = 'foo';
   document.body.innerText = 'bar';
   document.body.firstChild.textContent = 'baz';
   
   // 每次变化都保留了上一次的值
   // ["foo", "foo", "bar"]
   ```

    

3. **观察子节点**

   `MutationObserver`可以观察目标节点子节点的添加和移除。要观察子节点，需要在`MutationObserverInit`对象中将`childList`属性设置为`true`。

   下面的例子演示了添加子节点：

   ```
   // 清空主体
   document.body.innerHTML = '';
   
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { childList: true });
   
   document.body.appendChild(document.createElement('div'));
   
   // [
   //   {
   //     addedNodes: NodeList[div],
   //     attributeName: null,
   //     attributeNamespace: null,
   //     oldValue: null,
   //     nextSibling: null,
   //     previousSibling: null,
   //     removedNodes: NodeList[],
   //     target: body,
   //     type: "childList",
   //   }
   // ]
   ```

   下面的例子演示了移除子节点：

   ```
   // 清空主体
   document.body.innerHTML = '';
   
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { childList: true });
   
   document.body.appendChild(document.createElement('div'));
   
   // [
   //   {
   //     addedNodes: NodeList[],
   //     attributeName: null,
   //     attributeNamespace: null,
   //     oldValue: null,
   //     nextSibling: null,
   //     previousSibling: null,
   //     removedNodes: NodeList[div],
   //     target: body,
   //     type: "childList",
   //   }
   // ]
   ```

   对子节点**重新排序**（尽管调用一个方法即可实现）会报告两次变化事件，因为从技术上会涉及先移除和再添加：

   ```
   // 清空主体
   document.body.innerHTML = '';
   
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   // 创建两个初始子节点
   document.body.appendChild(document.createElement('div'));
   document.body.appendChild(document.createElement('span'));
   
   observer.observe(document.body, { childList: true });
   
   // 交换子节点顺序
   document.body.insertBefore(document.body.lastChild, document.body.firstChild);
   
   // 发生了两次变化：第一次是节点被移除，第二次是节点被添加
   // [
   //   {
   //     addedNodes: NodeList[],
   //     attributeName: null,
   //     attributeNamespace: null,
   //     oldValue: null,
   //     nextSibling: null,
   //     previousSibling: div,
   //     removedNodes: NodeList[span],
   //     target: body,
   //       type: childList,
   //   },
   //   {
   //     addedNodes: NodeList[span],
   //     attributeName: null,
   //     attributeNamespace: null,
   //     oldValue: null,
   //     nextSibling: div,
   //     previousSibling: null,
   //     removedNodes: NodeList[],
   //     target: body,
   //     type: "childList",
   //   }
   // ]
   ```

    

4. **观察子树**

   默认情况下，`MutationObserver`将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树（所有后代节点），这需要在`MutationObserverInit`对象中将`subtree`属性设置为`true`。

   下面的代码展示了观察元素及其后代节点属性的变化：

   ```
   // 清空主体
   document.body.innerHTML = '';
   
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   // 创建一个后代
   document.body.appendChild(document.createElement('div'));
   
   // 观察<body>元素及其子树
   observer.observe(document.body, { attributes: true, subtree: true });
   
   // 修改<body>元素的子树
   document.body.firstChild.setAttribute('foo', 'bar');
   
   // 记录了子树变化的事件
   // [
   //   {
   //     addedNodes: NodeList[],
   //     attributeName: "foo",
   //     attributeNamespace: null,
   //     oldValue: null,
   //     nextSibling: null,
   //     previousSibling: null,
   //     removedNodes: NodeList[],
   //     target: div,
   //     type: "attributes",
   //   }
   // ]
   ```

   有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。

   下面的代码演示了这种情况：

   ```
   // 清空主体
   document.body.innerHTML = '';
   
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   let subtreeRoot = document.createElement('div'),
       subtreeLeaf = document.createElement('span');
   
   // 创建包含两层的子树
   document.body.appendChild(subtreeRoot);
   subtreeRoot.appendChild(subtreeLeaf);
   
   // 观察子树
   observer.observe(subtreeRoot, { attributes: true, subtree: true });
   
   // 把节点转移到其他子树
   document.body.insertBefore(subtreeLeaf, subtreeRoot);
   
   subtreeLeaf.setAttribute('foo', 'bar');
   
   // 移出的节点仍然触发变化事件
   // [MutationRecord]
   ```

### 14.3.3　异步回调与记录队列

`MutationObserver`接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在`MutationRecord`实例中，然后添加到**记录队列**。这个队列对每个`MutationObserver`实例都是唯一的，是所有DOM变化事件的有序列表。

1. **记录队列**

   每次`MutationRecord`被添加到`MutationObserver`的记录队列时，仅当之前没有已排期的微任务回调时（队列中微任务长度为0），才会将观察者注册的回调（在初始化`MutationObserver`时传入）作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。

   不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一个`MutationRecord`实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些`MutationRecord`就用不着了，因此记录队列会被清空，其内容会被丢弃。
    

2. **`takeRecords()`方法**

   调用`MutationObserver`实例的`takeRecords()`方法可以清空记录队列，取出并返回其中的所有`MutationRecord`实例。看这个例子：

   ```
   let observer = new MutationObserver(
       (mutationRecords) => console.log(mutationRecords));
   
   observer.observe(document.body, { attributes: true });
   
   document.body.className = 'foo';
   document.body.className = 'bar';
   document.body.className = 'baz';
   
   console.log(observer.takeRecords());
   console.log(observer.takeRecords());
   
   // [MutationRecord, MutationRecord, MutationRecord]
   // []
   ```

   这在希望断开与观察目标的联系，但又希望处理由于调用`disconnect()`而被抛弃的记录队列中的`MutationRecord`实例时比较有用。

### 14.3.4　性能、内存与垃圾回收

DOM Level 2规范中描述的`MutationEvent`定义了一组会在各种DOM变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3规定废弃了这些事件。`MutationObserver`接口就是为替代这些事件而设计的更实用、性能更好的方案。

将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为`MutationObserver`而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。

无论如何，使用`MutationObservder`仍然**不是没有代价**的。因此理解什么时候避免出现这种情况就很重要了。

1. **`MutationObserver`的引用**

   `MutationObserver`实例与目标节点之间的引用关系是非对称的。`MutationObserver`拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。

   然而，目标节点却拥有对`MutationObserver`的强引用。如果目标节点从DOM中被移除，随后被垃圾回收，则关联的`MutationObserver`也会被垃圾回收。
    

2. **`MutationRecord`的引用**

   记录队列中的每个`MutationRecord`实例至少包含对已有DOM节点的一个引用。如果变化是`childList`类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个`MutationRecord`，然后让它们超出作用域并被垃圾回收。

   有时候可能需要保存某个观察者的完整变化记录。保存这些`MutationRecord`实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个`MutationRecord`中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃`MutationRecord`。

## 14.4　小结

文档对象模型（DOM，Document Object Model）是语言中立的HTML和XML文档的API。DOM Level 1将HTML和XML文档定义为一个节点的多层级结构，并暴露出JavaScript接口以操作文档的底层结构和外观。

DOM由一系列节点类型构成，主要包括以下几种。

- `Node`是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承`Node`。
- `Document`类型表示整个文档，对应树形结构的根节点。在JavaScript中，`document`对象是`Document`的实例，拥有查询和获取节点的很多方法。
- `Element`节点表示文档中所有HTML或XML元素，可以用来操作它们的内容和属性。
- 其他节点类型分别表示文本内容、注释、文档类型、CDATA区块和文档片段。

DOM编程在多数情况下没什么问题，在涉及`<script>`和`<style>`元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。

要理解DOM，最关键的一点是知道影响其性能的问题所在。DOM操作在JavaScript代码中是代价比较高的，`NodeList`对象尤其需要注意。`NodeList`对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少DOM操作的数量。

`MutationObserver`是为代替性能不好的`MutationEvent`而问世的。使用它可以有效精准地监控DOM变化，而且API也相对简单。

## 第 15 章　DOM扩展

> **本章内容**
>
> - 理解Selectors API
> - 使用HTML5 DOM扩展

尽管DOM API已经相当不错，但仍然不断有标准或专有的扩展出现，以支持更多功能。2008年以前，大部分浏览器对DOM的扩展是专有的。此后，W3C开始着手将这些已成为事实标准的专有扩展编制成正式规范。

基于以上背景，诞生了描述DOM扩展的两个标准：Selectors API与HTML5。这两个标准体现了社区需求和标准化某些手段及API的愿景。另外还有较小的Element Traversal规范，增加了一些DOM属性。专有扩展虽然还有，但这两个规范（特别是HTML5）已经涵盖其中大部分。本章也会讨论专有扩展。

本章所有内容已经得到市场占有率名列前茅的所有主流浏览器支持，除非特别说明。

## 15.1　Selectors API

JavaScript库中最流行的一种能力就是根据CSS选择符的模式匹配DOM元素。比如，jQuery就完全以CSS选择符查询DOM获取元素引用，而不是使用`getElementById()`和`getElementsByTagName()`。

Selectors API（参见W3C网站上的Selectors API Level 1）是W3C推荐标准，规定了浏览器原生支持的CSS查询API。支持这一特性的所有JavaScript库都会实现一个基本的CSS解析器，然后使用已有的DOM方法搜索文档并匹配目标节点。虽然库开发者在不断改进其性能，但JavaScript代码能做到的毕竟有限。通过浏览器原生支持这个API，解析和遍历DOM树可以通过底层编译语言实现，性能也有了数量级的提升。

Selectors API Level 1的核心是两个方法：`querySelector()`和`querySelectorAll()`。在兼容浏览器中，`Document`类型和`Element`类型的实例上都会暴露这两个方法。

Selectors API Level 2规范在`Element`类型上新增了更多方法，比如`matches()`、`find()`和`findAll()`。不过，目前还没有浏览器实现或宣称实现`find()`和`findAll()`。

### 15.1.1　`querySelector()`

`querySelector()`方法接收CSS选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回`null`。下面是一些例子：

```
// 取得<body>元素
let body = document.querySelector("body");

// 取得ID为"myDiv"的元素
let myDiv = document.querySelector("#myDiv");

// 取得类名为"selected"的第一个元素
let selected = document.querySelector(".selected");

// 取得类名为"button"的图片
let img = document.body.querySelector("img.button");
```

在`Document`上使用`querySelector()`方法时，会从文档元素开始搜索；在`Element`上使用`querySelector()`方法时，则只会从当前元素的后代中查询。

用于查询模式的CSS选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符，则`querySelector()`方法会抛出错误。

### 15.1.2　`querySelectorAll()`

`querySelectorAll()`方法跟`querySelector()`一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个`NodeList`的静态实例。

再强调一次，`querySelectorAll()`返回的`NodeList`实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用`NodeList`对象可能造成的性能问题。

以有效CSS选择符调用`querySelectorAll()`都会返回`NodeList`，无论匹配多少个元素都可以。如果没有匹配项，则返回空的`NodeList`实例。

与`querySelector()`一样，`querySelectorAll()`也可以在`Document`、`DocumentFragment`和`Element`类型上使用。下面是几个例子：

```
// 取得ID为"myDiv"的<div>元素中的所有<em>元素
let ems = document.getElementById("myDiv").querySelectorAll("em");

// 取得所有类名中包含"selected"的元素
let selecteds = document.querySelectorAll(".selected");

// 取得所有是<p>元素子元素的<strong>元素
let strongs = document.querySelectorAll("p strong");
```

返回的`NodeList`对象可以通过`for-of`循环、`item()`方法或中括号语法取得个别元素。比如：

```
let strongElements = document.querySelectorAll("p strong");

// 以下3个循环的效果一样

for (let strong of strongElements) {
  strong.className = "important";
}

for (let i = 0; i < strongElements.length; ++i) {
  strongElements.item(i).className = "important";
}

for (let i = 0; i < strongElements.length; ++i) {
  strongElements [i].className = "important";
}
```

与`querySelector()`方法一样，如果选择符有语法错误或碰到不支持的选择符，则`querySelectorAll()`方法会抛出错误。

### 15.1.3　`matches()`

`matches()`方法（在规范草案中称为`matchesSelector()`）接收一个CSS选择符参数，如果元素匹配则该选择符返回`true`，否则返回`false`。例如：

```
if (document.body.matches ("body.page1")){
  // true
}
```

使用这个方法可以方便地检测某个元素会不会被`querySelector()`或`querySelectorAll()`方法返回。

所有主流浏览器都支持`matches()`。Edge、Chrome、Firefox、Safari和Opera完全支持，IE9~11及一些移动浏览器支持带前缀的方法。

## 15.2　元素遍历

IE9之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了`childNodes`和`firstChild`等属性上的差异。为了弥补这个差异，同时不影响DOM规范，W3C通过新的Element Traversal规范定义了一组新属性。

Element Traversal API为DOM元素添加了5个属性：

- `childElementCount`，返回子元素数量（不包含文本节点和注释）；
- `firstElementChild`，指向第一个`Element`类型的子元素（`Element`版`firstChild`）；
- `lastElementChild`，指向最后一个`Element`类型的子元素（`Element`版`lastChild`）；
- `previousElementSibling`，指向前一个`Element`类型的同胞元素（`Element`版`previousSibling`）；
- `nextElementSibling`，指向后一个`Element`类型的同胞元素（`Element`版`nextSibling`）。

在支持的浏览器中，所有DOM元素都会有这些属性，为遍历DOM元素提供便利。这样开发者就不用担心空白文本节点的问题了。

举个例子，过去要以跨浏览器方式遍历特定元素的所有子元素，代码大致是这样写的：

```
let parentElement = document.getElementById('parent');
let currentChildNode = parentElement.firstChild;

// 没有子元素，firstChild返回null，跳过循环
while (currentChildNode) {
  if (currentChildNode.nodeType === 1) {
    // 如果有元素节点，则做相应处理
    processChild(currentChildNode);
  }
  if (currentChildNode === parentElement.lastChild) {
    break;
  }
  currentChildNode = currentChildNode.nextSibling;
}
```

使用Element Traversal属性之后，以上代码可以简化如下：

```
let parentElement = document.getElementById('parent');
let currentChildElement = parentElement.firstElementChild;

// 没有子元素，firstElementChild返回null，跳过循环
while (currentChildElement) {
  // 这就是元素节点，做相应处理
  processChild(currentChildElement);
  if (currentChildElement === parentElement.lastElementChild) {
    break;
  }
  currentChildElement = currentChildElement.nextElementSibling;
}
```

IE9及以上版本，以及所有现代浏览器都支持Element Traversal属性。

## 15.3　HTML5

HTML5代表着与以前的HTML截然不同的方向。在所有以前的HTML规范中，从未出现过描述JavaScript接口的情形，HTML就是一个纯标记语言。JavaScript绑定的事，一概交给DOM规范去定义。

然而，HTML5规范却包含了与标记相关的大量JavaScript API定义。其中有的API与DOM重合，定义了浏览器应该提供的DOM扩展。

> **注意**　因为HTML5覆盖的范围极其广泛，所以本节主要讨论其影响所有DOM节点的部分。HTML5的其他部分将在本书后面的相关章节中再讨论。

### 15.3.1　CSS类扩展

自HTML4被广泛采用以来，Web开发中一个主要的变化是`class`属性用得越来越多，其用处是为元素添加样式以及语义信息。自然地，JavaScript与CSS类的交互就增多了，包括动态修改类名，以及根据给定的一个或一组类名查询元素，等等。为了适应开发者和他们对`class`属性的认可，HTML5增加了一些特性以方便使用CSS类。

1. **`getElementsByClassName()`**

   `getElementsByClassName()`是HTML5新增的最受欢迎的一个方法，暴露在`document`对象和所有HTML元素上。 这个方法脱胎于基于原有DOM特性实现该功能的JavaScript库，提供了性能高好的原生实现。

   `getElementsByClassName()`方法接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的`NodeList`。如果提供了多个类名，则顺序无关紧要。下面是几个示例：

   ```
   // 取得所有类名中包含"username"和"current"元素
   // 这两个类名的顺序无关紧要
   let allCurrentUsernames = document.getElementsByClassName("username current");
   // 取得ID为"myDiv"的元素子树中所有包含"selected"类的元素
   let selected = document.getElementById("myDiv").getElementsByClassName("selected");
   ```

   这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在`document`上调用`getElementsByClassName()`返回文档中所有匹配的元素，而在特定元素上调用`getElementsByClassName()`则返回该元素后代中匹配的元素。

   如果要给包含特定类（而不是特定ID或标签）的元素添加事件处理程序，使用这个方法会很方便。不过要记住，因为返回值是`NodeList`，所以使用这个方法会遇到跟使用`getElementsByTagName()`和其他返回`NodeList`对象的DOM方法同样的问题。

   IE9及以上版本，以及所有现代浏览器都支持`getElementsByClassName()`方法。
    

2. **`classList`属性**

   要操作类名，可以通过`className`属性实现添加、删除和替换。但`className`是一个字符串，所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。以下面的HTML代码为例：

   ```
   <div class="bd user disabled">...</div>
   ```

   这个`<div>`元素有3个类名。要想删除其中一个，就得先把`className`拆开，删除不想要的那个，再把包含剩余类的字符串设置回去。比如：

   ```
   // 要删除"user"类
   let targetClass = "user";
   
   // 把类名拆成数组
   let classNames = div.className.split(/\s+/);
   
   // 找到要删除类名的索引
   let idx = classNames.indexOf(targetClass);
   
   // 如果有则删除
   if (idx > -1) {
     classNames.splice(i,1);
   }
   
   // 重新设置类名
   div.className = classNames.join(" ");
   ```

   这就是从`<div>`元素的类名中删除`"user"`类要写的代码。替换类名和检测类名也要涉及同样的算法。添加类名只涉及字符串拼接，但必须先检查一下以确保不会重复添加相同的类名。很多JavaScript库为这些操作实现了便利方法。

   HTML5通过给所有元素增加`classList`属性为这些操作提供了更简单也更安全的实现方式。`classList`是一个新的集合类型`DOMTokenList`的实例。与其他DOM集合类型一样，`DOMTokenList`也有`length`属性表示自己包含多少项，也可以通过`item()`或中括号取得个别的元素。此外，`DOMTokenList`还增加了以下方法。

   - `add(*value*)`，向类名列表中添加指定的字符串值`value`。如果这个值已经存在，则什么也不做。
   - `contains(*value*)`，返回布尔值，表示给定的`value`是否存在。
   - `remove(*value*)`，从类名列表中删除指定的字符串值`value`。
   - `toggle(*value*)`，如果类名列表中已经存在指定的`value`，则删除；如果不存在，则添加。

   这样一来，前面的例子中那么多行代码就可以简化成下面的一行：

   ```
   div.classList.remove("user");
   ```

   这行代码可以在不影响其他类名的情况下完成删除。其他方法同样极大地简化了操作类名的复杂性，如下面的例子所示：

   ```
   // 删除"disabled"类
   div.classList.remove("disabled");
   
   // 添加"current"类
   div.classList.add("current");
   
   // 切换"user"类
   div.classList.toggle("user");
   
   // 检测类名
   if (div.classList.contains("bd") && !div.classList.contains("disabled")){
     // 执行操作
   )
   
   // 迭代类名
   for (let class of div.classList){
     doStuff(class);
   }
   ```

   添加了`classList`属性之后，除非是完全删除或完全重写元素的`class`属性，否则`className`属性就用不到了。IE10及以上版本（部分）和其他主流浏览器（完全）实现了`classList`属性。

### 15.3.2　焦点管理

HTML5增加了辅助DOM焦点管理的功能。首先是`document.activeElement`，始终包含当前拥有焦点的DOM元素。页面加载时，可以通过用户输入（按Tab键或代码中使用`focus()`方法）让某个元素自动获得焦点。例如：

```
let button = document.getElementById("myButton");
button.focus();
console.log(document.activeElement === button); // true
```

默认情况下，`document.activeElement`在页面刚加载完之后会设置为`document.body`。而在页面完全加载之前，`document.activeElement`的值为`null`。

其次是`document.hasFocus()`方法，该方法返回布尔值，表示文档是否拥有焦点：

```
let button = document.getElementById("myButton");
button.focus();
console.log(document.hasFocus()); // true
```

确定文档是否获得了焦点，就可以帮助确定用户是否在操作页面。

第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点，而这对于保证Web应用程序的无障碍使用是非常重要的。无障碍Web应用程序的一个重要方面就是焦点管理，而能够确定哪个元素当前拥有焦点（相比于之前的猜测）是一个很大的进步。

### 15.3.3　`HTMLDocument`扩展

HTML5扩展了`HTMLDocument`类型，增加了更多功能。与其他HTML5定义的DOM扩展一样，这些变化同样基于所有浏览器事实上都已经支持的专有扩展。为此，即使这些扩展的标准化相对较晚，很多浏览器也早就实现了相应的功能。

1. **`readyState`属性**

   `readyState`是IE4最早添加到`document`对象上的属性，后来其他浏览器也都依葫芦画瓢地支持这个属性。最终，HTML5将这个属性写进了标准。`document.readyState`属性有两个可能的值：

   - `loading`，表示文档正在加载；
   - `complete`，表示文档加载完成。

   实际开发中，最好是把`document.readState`当成一个指示器，以判断文档是否加载完毕。在这个属性得到广泛支持以前，通常要依赖`onload`事件处理程序设置一个标记，表示文档加载完了。这个属性的基本用法如下：

   ```
   if (document.readyState == "complete"){
     // 执行操作
   }
   ```

    

2. **`compatMode`属性**

   自从IE6提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。IE为`document`添加了`compatMode`属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。如下面的例子所示，标准模式下`document.compatMode`的值是`"CSS1Compat"`，而在混杂模式下，`document.compatMode`的值是`"BackCompat"`：

   ```
   if (document.compatMode == "CSS1Compat"){
     console.log("Standards mode");
   } else {
     console.log("Quirks mode");
   }
   ```

   HTML5最终也把`compatMode`属性的实现标准化了。
    

3. **`head`属性**

   作为对`document.body`（指向文档的`<body>`元素）的补充，HTML5增加了`document.head`属性，指向文档的`<head>`元素。可以像下面这样直接取得`<head>`元素：

   ```
   let head = document.head;
   ```

### 15.3.4　字符集属性

HTML5增加了几个与文档字符集有关的新属性。其中，`characterSet`属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是`"UTF-16"`，但可以通过`<meta>`元素或响应头，以及新增的`characterSeet`属性来修改。下面是一个例子：

```
console.log(document.characterSet); // "UTF-16"
document.characterSet = "UTF-8";
```

### 15.3.5　自定义数据属性

HTML5允许给元素指定非标准的属性，但要使用前缀`data-`以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，`data-`后面跟什么都可以。下面是一个例子：

```
<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
```

定义了自定义数据属性后，可以通过元素的`dataset`属性来访问。`dataset`属性是一个`DOMStringMap`的实例，包含一组键/值对映射。元素的每个`data-name`属性在`dataset`中都可以通过`data-`后面的字符串作为键来访问（例如，属性`data-myname`、`data-myName`可以通过`myname`访问，但要注意`data-my-name`、`data-My-Name`要通过`myName`来访问）。下面是一个使用自定义数据属性的例子：

```
// 本例中使用的方法仅用于示范

let div = document.getElementById("myDiv");

// 取得自定义数据属性的值
let appId = div.dataset.appId;
let myName = div.dataset.myname;

// 设置自定义数据属性的值
div.dataset.appId = 23456;
div.dataset.myname = "Michael";

// 有"myname"吗？
if (div.dataset.myname){
  console.log('Hello, ${div.dataset.myname}');
}
```

自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识页面的不同部分。另外，单页应用程序框架也非常多地使用了自定义数据属性。

### 15.3.6　插入标记

DOM虽然已经为操纵节点提供了很多API，但向文档中一次性插入大量HTML时还是比较麻烦。相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个HTML字符串要简单（快速）得多。HTML5已经通过以下DOM扩展将这种能力标准化了。

1. **`innerHTML`属性**

   在读取`innerHTML`属性时，会返回元素所有后代的HTML字符串，包括元素、注释和文本节点。而在写入`innerHTML`时，则会根据提供的字符串值以新的DOM子树替代元素中原来包含的所有节点。比如下面的HTML代码：

   ```
   <div id="content">
     <p>This is a <strong>paragraph</strong> with a list following it.</p>
     <ul>
       <li>Item 1</li>
       <li>Item 2</li>
       <li>Item 3</li>
     </ul>
   </div>
   ```

   对于这里的`<div>`元素而言，其`innerHTML`属性会返回以下字符串：

   ```
   <p>This is a <strong>paragraph</strong> with a list following it.</p>
   <ul>
     <li>Item 1</li>
     <li>Item 2</li>
     <li>Item 3</li>
   </ul>
   ```

   实际返回的文本内容会因浏览器而不同。IE和Opera会把所有元素标签转换为大写，而Safari、Chrome和Firefox则会按照文档源代码的格式返回，包含空格和缩进。因此不要指望不同浏览器的`innerHTML`会返回完全一样的值。

   在写入模式下，赋给`innerHTML`属性的值会被解析为DOM子树，并替代元素之前的所有节点。因为所赋的值默认为HTML，所以其中的所有标签都会以浏览器处理HTML的方式转换为元素（同样，转换结果也会因浏览器不同而不同）。如果赋值中不包含任何HTML标签，则直接生成一个文本节点，如下所示：

   ```
   div.innerHTML = "Hello world!";
   ```

   因为浏览器会解析设置的值，所以给`innerHTML`设置包含HTML的字符串时，结果会大不一样。来看下面的例子：

   ```
   div.innerHTML = "Hello & welcome, <b>\"reader\"!</b>";
   ```

   这个操作的结果相当于：

   ```
   <div id="content">Hello &amp; welcome, <b>&quot;reader&quot;!</b></div>
   ```

   设置完`innerHTML`，马上就可以像访问其他节点一样访问这些新节点。

   > **注意**　设置`innerHTML`会导致浏览器将HTML字符串解析为相应的DOM树。这意味着设置`innerHTML`属性后马上再读出来会得到不同的字符串。这是因为返回的字符串是将原始字符串对应的DOM子树序列化之后的结果。

    

2. **旧IE中的`innerHTML`**

   在所有现代浏览器中，通过`innerHTML`插入的`<script>`标签是不会执行的。而在IE8及之前的版本中，只要这样插入的`<script>`元素指定了`defer`属性，且`<script>`之前是“受控元素”（scoped element），那就是可以执行的。`<script>`元素与`<style>`或注释一样，都是“非受控元素”（NoScope element），也就是在页面上看不到它们。IE会把`innerHTML`中从非受控元素开始的内容都删掉，也就是说下面的例子是行不通的：

   ```
   // 行不通
   div.innerHTML = "<script defer>console.log('hi');<\/script>";
   ```

   在这个例子中，`innerHTML`字符串以一个非受控元素开始，因此整个字符串都会被清空。为了达到目的，必须在`<script>`前面加上一个受控元素，例如文本节点或没有结束标签的元素（如`<input>`）。因此，下面的代码就是可行的：

   ```
   // 以下都可行
   div.innerHTML = "_<script defer>console.log('hi');<\/script>";
   div.innerHTML = "<div>&nbsp;</div><script defer>console.log('hi');<\/script>";
   div.innerHTML = "<input type=\"hidden\"><script defer>console.
   log('hi');<\/script>";
   ```

   第一行会在`<script>`元素前面插入一个文本节点。为了不影响页面排版，可能稍后需要删掉这个文本节点。第二行与之类似，使用了包含空格的`<div>`元素。空`<div>`是不行的，必须包含一点内容，以强制创建一个文本节点。同样，这个`<div>`元素可能也需要事后删除，以免影响页面外观。第三行使用了一个隐藏的`<input>`字段来达成同样的目的。因为这个字段不影响页面布局，所以应该是最理想的方案。

   在IE中，通过`innerHTML`插入`<style>`也会有类似的问题。多数浏览器支持使用`innerHTML`插入`<style>`元素：

   ```
   div.innerHTML = "<style type=\"text/css\">body {background-color: red; }</style>";
   ```

   但在IE8及之前的版本中，`<style>`也被认为是非受控元素，所以必须前置一个受控元素：

   ```
   div.innerHTML = "_<style type=\"text/css\">body {background-color: red; }</style>";
   div.removeChild(div.firstChild);
   ```

   > **注意**　Firefox在内容类型为`application`/`xhtml+xml`的XHTML文档中对`innerHTML`更加严格。在XHTML文档中使用`innerHTML`，必须使用格式良好的XHTML代码。否则，在Firefox中会静默失败。

    

3. **`outerHTML`属性**

   读取`outerHTML`属性时，会返回调用它的元素（及所有后代元素）的HTML字符串。在写入`outerHTML`属性时，调用它的元素会被传入的HTML字符串经解释之后生成的DOM子树取代。比如下面的HTML代码：

   ```
   <div id="content">
     <p>This is a <strong>paragraph</strong> with a list following it.</p>
     <ul>
       <li>Item 1</li>
       <li>Item 2</li>
       <li>Item 3</li>
     </ul>
   </div>
   ```

   在这个`<div>`元素上调用`outerHTML`会返回相同的字符串，包括`<div>`本身。注意，浏览器因解析和解释HTML代码的机制不同，返回的字符串也可能不同。（跟`innerHTML`的情况是一样的。）

   如果使用`outerHTML`设置HTML，比如：

   ```
   div.outerHTML = "<p>This is a paragraph.</p>";
   ```

   则会得到与执行以下脚本相同的结果：

   ```
   let p = document.createElement("p");
   p.appendChild(document.createTextNode("This is a paragraph."));
   div.parentNode.replaceChild(p, div);
   ```

   新的`<p>`元素会取代DOM树中原来的`<div>`元素。
    

4. **`insertAdjacentHTML()`与`insertAdjacentText()`**

   关于插入标签的最后两个新增方法是`insertAdjacentHTML()`和`insertAdjacentText()`。这两个方法最早源自IE，它们都接收两个参数：要插入标记的位置和要插入的HTML或文本。第一个参数必须是下列值中的一个：

   - `"beforebegin"`，插入当前元素前面，作为前一个同胞节点；
   - `"afterbegin"`，插入当前元素内部，作为新的子节点或放在第一个子节点前面；
   - `"beforeend"`，插入当前元素内部，作为新的子节点或放在最后一个子节点前面；
   - `"afterend"`，插入当前元素后面，作为下一个同胞节点。

   注意这几个值是不区分大小写的。第二个参数会作为HTML字符串解析（与`innerHTML`和`outerHTML`相同）或者作为纯文本解析（与`innerText`和`outerText`相同）。如果是HTML，则会在解析出错时抛出错误。下面展示了基本用法**1**：

   ```
   // 作为前一个同胞节点插入
   element.insertAdjacentHTML("beforebegin", "<p>Hello world!</p>");
   element.insertAdjacentText("beforebegin", "Hello world!");
   
   // 作为第一个子节点插入
   element.insertAdjacentHTML("afterbegin", "<p>Hello world!</p>");
   element.insertAdjacentText("afterbegin", "Hello world!");
   
   // 作为最后一个子节点插入
   element.insertAdjacentHTML("beforeend", "<p>Hello world!</p>");
   element.insertAdjacentText("beforeend", "Hello world!");
   
   // 作为下一个同胞节点插入
   element.insertAdjacentHTML("afterend", "<p>Hello world!</p>"); element.
   insertAdjacentText("afterend", "Hello world!");
   ```

    

5. **内存与性能问题**

   使用本节介绍的方法替换子节点可能在浏览器（特别是IE）中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他JavaScript对象（作为元素的属性），那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用`innerHTML`、`outerHTML`和`insertAdjacentHTML()`之前，最好手动删除要被替换的元素上关联的事件处理程序和JavaScript对象。

   使用这些属性当然有其方便之处，特别是`innerHTML`。一般来讲，插入大量的新HTML使用`innerHTML`比使用多次DOM操作创建节点再插入来得更便捷。这是因为HTML解析器会解析设置给`innerHTML`（或`outerHTML`）的值。解析器在浏览器中是底层代码（通常是C++代码），比JavaScript快得多。不过，HTML解析器的构建与解构也不是没有代价，因此最好限制使用`innerHTML`和`outerHTML`的次数。比如，下面的代码使用`innerHTML`创建了一些列表项：

   ```
   for (let value of values){
     ul.innerHTML += '<li>${value}</li>';  // 别这样做！
   }
   ```

   这段代码效率低，因为每次迭代都要设置一次`innerHTML`。不仅如此，每次循环还要先读取`innerHTML`，也就是说循环一次要访问两次`innerHTML`。为此，最好通过循环先构建一个独立的字符串，最后再一次性把生成的字符串赋值给`innerHTML`，比如：

   ```
   let itemsHtml = "";
   for (let value of values){
     itemsHtml += '<li>${value}</li>';
   }
   ul.innerHTML = itemsHtml;
   ```

   这样修改之后效率就高多了，因为只有对`innerHTML`的一次赋值。当然，像下面这样一行代码也可以搞定：

   ```
   ul.innerHTML = values.map(value => '<li>${value}</li>').join('');
   ```

    

6. **跨站点脚本**

   尽管`innerHTML`不会执行自己创建的`<script>`标签，但仍然向恶意用户暴露了很大的攻击面，因为通过它可以毫不费力地创建元素并执行`onclick`之类的属性。

   如果页面中要使用用户提供的信息，则不建议使用`innerHTML`。与使用`innerHTML`获得的方便相比，防止XSS攻击更让人头疼。此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。

**1**假设当前元素是`<p>Hello world!</p>`，则`"beforebegin"`和`"afterbegin"`中的`"begin"`指开始标签`<p>`；而`"afterend"`和`"beforeend"`中的`"end"`指结束标签`</p>`。——译者注

### 15.3.7　`scrollIntoView()`

DOM规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5选择了标准化`scrollIntoView()`。

`scrollIntoView()`方法存在于所有HTML元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下：

- ```
  alignToTop
  ```

  是一个布尔值。

  - `true`：窗口滚动后元素的顶部与视口顶部对齐。
  - `false`：窗口滚动后元素的底部与视口底部对齐。

- ```
  scrollIntoViewOptions
  ```

  是一个选项对象。

  - `behavior`：定义过渡动画，可取的值为`"smooth"`和`"auto"`，默认为`"auto"`。
  - `block`：定义垂直方向的对齐，可取的值为`"start"`、`"center"`、`"end"`和`"nearest"`，默认为 `"start"`。
  - `inline`：定义水平方向的对齐，可取的值为`"start"`、`"center"`、`"end"`和`"nearest"`，默认为 `"nearest"`。

- 不传参数等同于`alignToTop`为`true`。

来看几个例子：

```
// 确保元素可见
document.forms[0].scrollIntoView();

// 同上
document.forms[0].scrollIntoView(true);
document.forms[0].scrollIntoView({block: 'start'});

// 尝试将元素平滑地滚入视口
document.forms[0].scrollIntoView({behavior: 'smooth', block: 'start'});
```

这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览器将元素滚动到可见位置。

## 15.4　专有扩展

尽管所有浏览器厂商都理解遵循标准的重要性，但它们也都有为弥补功能缺失而为DOM添加专有扩展的历史。虽然这表面上看是一件坏事，但专有扩展也为开发者提供了很多重要功能，而这些功能后来则有可能被标准化，比如进入HTML5。

除了已经标准化的，各家浏览器还有很多未被标准化的专有扩展。这并不意味着它们将来不会被纳入标准，只不过在本书编写时，它们还只是由部分浏览器专有和采用。

### 15.4.1　`children`属性

IE9之前的版本与其他浏览器在处理空白文本节点上的差异导致了`children`属性的出现。`children`属性是一个`HTMLCollection`，只包含元素的`Element`类型的子节点。如果元素的子节点类型全部是元素类型，那`children`和`childNodes`中包含的节点应该是一样的。可以像下面这样使用`children`属性：

```
let childCount = element.children.length;
let firstChild = element.children[0];
```

### 15.4.2　`contains()`方法

DOM编程中经常需要确定一个元素是不是另一个元素的后代。IE首先引入了`contains()`方法，让开发者可以在不遍历DOM的情况下获取这个信息。`contains()`方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。

如果目标节点是被搜索节点的后代，`contains()`返回`true`，否则返回`false`。下面看一个例子：

```
console.log(document.documentElement.contains(document.body)); // true
```

这个例子测试`<html>`元素中是否包含`<body>`元素，在格式正确的HTML中会返回`true`。

另外，使用DOM Level 3的`compareDocumentPosition()`方法也可以确定节点间的关系。这个方法会返回表示两个节点关系的位掩码。下表给出了这些位掩码的说明。

| 掩码 | 节点关系                                    |
| :--- | :------------------------------------------ |
| 0x1  | 断开（传入的节点不在文档中）                |
| 0x2  | 领先（传入的节点在DOM树中位于参考节点之前） |
| 0x4  | 随后（传入的节点在DOM树中位于参考节点之后） |
| 0x8  | 包含（传入的节点是参考节点的祖先）          |
| 0x10 | 被包含（传入的节点是参考节点的后代）        |

要模仿`contains()`方法，就需要用到掩码16（0x10）。`compareDocumentPosition()`方法的结果可以通过按位与来确定参考节点是否包含传入的节点，比如：

```
let result = document.documentElement.compareDocumentPosition(document.body);
console.log(!!(result & 0x10));
```

以上代码执行后result的值为20（或0x14，其中0x4表示“随后”，加上0x10“被包含”）。对`result`和0x10应用按位与会返回非零值，而两个叹号将这个值转换成对应的布尔值。

IE9及之后的版本，以及所有现代浏览器都支持`contains()`和`compareDocumentPosition()`方法。

### 15.4.3　插入标记

HTML5将IE发明的`innerHTML`和`outerHTML`纳入了标准，但还有两个属性没有入选。这两个剩下的属性是`innerText`和`outerText`。

1. **`innerText`属性**

   `innerText`属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，`innerText`会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，`innerText`会移除元素的所有后代并插入一个包含该值的文本节点。来看下面的HTML代码：

   ```
   <div id="content">
     <p>This is a <strong>paragraph</strong> with a list following it.</p>
     <ul>
       <li>Item 1</li>
       <li>Item 2</li>
       <li>Item 3</li>
     </ul>
   </div>
   ```

   对这个例子中的`<div>`而言，`innerText`属性会返回以下字符串：

   ```
   This is a paragraph with a list following it.
   Item 1
   Item 2
   Item 3
   ```

   注意不同浏览器对待空格的方式不同，因此格式化之后的字符串可能包含也可能不包含原始HTML代码中的缩进。

   下面再看一个使用`innerText`设置`<div>`元素内容的例子：

   ```
   div.innerText = "Hello world!";
   ```

   执行这行代码后，HTML页面中的这个`<div>`元素实际上会变成这个样子：

   ```
   <div id="content">Hello world!</div>
   ```

   设置`innerText`会移除元素之前所有的后代节点，完全改变DOM子树。此外，设置`innerText`也会编码出现在字符串中的HTML语法字符（小于号、大于号、引号及和号）。下面是一个例子：

   ```
   div.innerText = "Hello & welcome, <b>\"reader\"!</b>";
   ```

   执行之后的结果如下：

   ```
   <div id="content">Hello &amp; welcome, &lt;b&gt;&quot;reader&quot;!&lt;/b&gt;</div>
   ```

   因为设置`innerText`只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必须进行HTML编码。`innerText`属性可以用于去除HTML标签。通过将`innerText`设置为等于`innerText`，可以去除所有HTML标签而只剩文本，如下所示：

   ```
   div.innerText = div.innerText;
   ```

   执行以上代码后，容器元素的内容只会包含原先的文本内容。

   > **注意**　Firefox 45（2016年3月发布）以前的版本中只支持`textContent`属性，与`innerText`的区别是返回的文本中也会返回行内样式或脚本代码。`innerText`目前已经得到所有浏览器支持，应该作为取得和设置文本内容的首选方法使用。

    

2. **`outerText`属性**

   `outerText`与`innerText`是类似的，只不过作用范围包含调用它的节点。要读取文本值时，`outerText`与`innerText`实际上会返回同样的内容。但在写入文本值时，`outerText`就大不相同了。写入文本值时，`outerText`不止会移除所有后代节点，而是会替换整个元素。比如：

   ```
   div.outerText = "Hello world!";
   ```

   这行代码的执行效果就相当于以下两行代码：

   ```
   let text = document.createTextNode("Hello world!");
   div.parentNode.replaceChild(text, div);
   ```

   本质上，这相当于用新的文本节点替代`outerText`所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。

   `outerText`是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除Firefox之外所有主流浏览器都支持`outerText`。

### 15.4.4　滚动

如前所述，滚动是HTML5之前DOM标准没有涉及的领域。虽然HTML5把`scrollIntoView()`标准化了，但不同浏览器中仍然有其他专有方法。比如，`scrollIntoViewIfNeeded()`作为`HTMLElement`类型的扩展可以在所有元素上调用。`scrollIntoViewIfNeeded(alingCenter)`会在元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法什么也不做。如果将可选的参数`alingCenter`设置为`true`，则浏览器会尝试将其放在视口中央。Safari、Chrome和Opera实现了这个方法。

下面使用`scrollIntoViewIfNeeded()`方法的一个例子：

```
// 如果不可见，则将元素可见
document.images[0].scrollIntoViewIfNeeded();
```

考虑到`scrollIntoView()`是唯一一个所有浏览器都支持的方法，所以只用它就可以了。

## 15.5　小结

虽然DOM规定了与XML和HTML文档交互的核心API，但其他几个规范也定义了对DOM的扩展。很多扩展都基于之前的已成为事实标准的专有特性标准化而来。本章主要介绍了以下3个规范。

- **Selectors API**为基于CSS选择符获取DOM元素定义了几个方法：`querySelector()`、`querySelectorAll()`和`matches()`。
- **Element Traversal**在DOM元素上定义了额外的属性，以方便对DOM元素进行遍历。这个需求是因浏览器处理元素间空格的差异而产生的。
- **HTML5**为标准DOM提供了大量扩展。其中包括对`innerHTML`属性等事实标准进行了标准化，还有焦点管理、字符集、滚动等特性。

DOM扩展的数量总体还不大，但随着Web技术的发展一定会越来越多。浏览器仍然没有停止对专有扩展的探索，如果出现成功的扩展，那么就可能成为事实标准，或者最终被整合到未来的标准中。